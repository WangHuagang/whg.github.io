<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Webpack 前端自动化部署项目至服务器（Vue）]]></title>
    <url>%2F2020%2F03%2F15%2FautoDeploy%2F</url>
    <content type="text"><![CDATA[对于没有搭建Jenkins等自动化打包平台来说，平时部署前端项目流程是：先部署到测试环境ok后再发布到生产环境上，部署到测试环境用 xshell 连上服务器，然后用 xftp /winSCP连接服务器，然后本地 build 项目，接着把 build 好的文件通过 xftp/winSCP 上传到服务器上，整个流程感觉稍有繁琐，重复。 我们可以利用scp2自动化部署到静态文件服务器，从而实现自动化部署前端项目！ 1、安装scp2scp2是一个基于ssh2增强实现，纯粹使用JavaScript编写。而ssh2就是一个使用nodejs对于SSH2的模拟实现。scp是Linux系统下基于SSH登陆进行安全的远程文件拷贝命令。这里我们就用这个功能，在Vue编译构建成功之后，将项目推送至测试/生产环境，以方便测试，提高效率。安装scp2：npm install scp2 --save-dev 2、配置测试/生产环境 服务器SSH远程登陆基本信息在项目根目录下新建deploy文件夹，再新建config.js来存放服务器的配置信息:123456789101112131415161718192021222324/** * 服务器相关配置 */const SERVER_LIST = [ &#123; id: 'test', name: '测试环境', host: '80.xxx.xx.xx', // ip port: 22, // 端口 username: 'root', password: '******', path: '/opt/xxx/front' // 项目静态文件存放地址 &#125;, &#123; id: 'prod', name: '正式环境', host: '101.x.xx.xx', port: 22, username: 'root', password: '******', path: '/opt/xxx/front' &#125;];module.exports = SERVER_LIST; 3、使用scp2库,创建自动化部署脚本12345678910111213141516171819202122232425const scpClient = require('scp2');const ora = require('ora');const chalk = require('chalk');const server = require('./config);const spinner = ora('正在发布到' + (process.env.NODE_ENV === 'prod' ? '生产' : '测试') + '服务器...');spinner.start();scpClient.scp( 'dist/', &#123; host: server.host, port: server.port, username: server.username, password: server.password, path: server.path &#125;, function (err) &#123; spinner.stop(); if (err) &#123; console.log(chalk.red('发布失败.\n')); throw err; &#125; else &#123; console.log(chalk.green('Success! 成功发布到' + (process.env.NODE_ENV === 'prod' ? '生产' : '测试') + '服务器! \n')); &#125; &#125;); 通过scp库我们就能把dist文件夹下的所有文件上传到服务器指定路径，从而完成我们项目的自动化部署。 4、添加 package.json 中的 scripts 命令, 自定义名称为 “deploy”12345"scripts": &#123; "serve": "vue-cli-service serve --mode dev", "build": "vue-cli-service build --mode prod", "deploy": "cross-env NODE_ENV=prod node ./deploy"&#125;, 至此，我们直接执行命令npm run deploy就能完成自动化部署。 但是，目前还有几个问题需要解决： 怎样区分多环境部署？ 服务器账号和密码为了保密不想写在配置里怎么办？ 想备份上一版本的文件怎么办？ 4.1 区分多环境部署 第一种方法：通过配置不同环境不同的部署命令来区分，比如：npm run deploy:test/npm run deploy:prod，然后通过不同命令的环境变量来读取不同的配置文件。 12"deploy:dev": "cross-env NODE_ENV=dev node ./deploy","deploy:prod": " cross-env NODE_ENV=prod node ./deploy" 第二种方法：通过用户从命令行的输入来获取部署的环境，将在下一点详细讲解。 4.2 服务器账号和密码为了保密不想写在配置里怎么办？为了保密性，这两个信息不会存放在配置文件里，那么我们可以通过node 的readline模块来让用户输入账号和密码。导入readline模块：const readline = require(&#39;readline&#39;); 创建readline实例：1234const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout&#125;) 利用readlinde的quetion方法来“提问”，然后接受用户输入的值：123rl.question(‘请输入服务器账号：’, (as) =&gt; &#123; console.log(as);&#125;) 至此，我们就能拿到用户输入的账号了。现在我们整理一下来获取用户输入的环境、账号、密码：123456789101112131415161718192021222324let server = null;const questions = ['Please input publish environment(test\\prod\\yanshi): ', 'Please input server username: ', 'Please input server password: ']const linelimit = 3; // 用户输入的行数let inputArr = [];let index = 0;function runQueLoop() &#123; if (index == linelimit) &#123; server = config.find(i =&gt; i.id == inputArr[0]) //通过id匹配环境 server.username = inputArr[1]; server.password = inputArr[2]; copyFile(); return; &#125; rl.question(questions[index], (as) =&gt; &#123; inputArr[index] = as; index++; runQueLoop() &#125;)&#125;rl.on('close', () =&gt; &#123; process.exit(0) &#125;)runQueLoop() OK, 我们拿到了用户输入的环境、服务器账号和密码，我们服务器的配置信息就完整了，并且保证了私密信息的保密性，也提升了与用户的交互。 4.3 如何备份上一版本的文件？备份文件我首先想到的就是通过使用Linux的命令行还进行文件的操作，大体的思路： 进入到静态文件存放的根目录； 新建一个备份文件夹（我们可以通过时间戳来命名，也方便回溯版本）； 将现在正运行版本文件夹下的所有文件拷贝的新建的备份文件夹； 文件备份就完成了，然后我们再把我们需要发布的静态文件上传即可！有了思路过后，我们来使用ssh2库来执行脚本命令，实现我们的思路：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var Client = require('ssh2').Client;var conn = new Client();function copyFile() &#123; let pathArr = server.path.split('/'), rootFolder = pathArr[pathArr.length-1];//获取根文件夹 pathArr.pop(); let rootPath = pathArr.join('/'); const conn = new Client(); conn.on('ready', function () &#123; conn.exec(`cd $&#123;rootPath&#125;\n mkdir $&#123;rootFolder&#125;$&#123;currTime&#125;\n cp -r $&#123;rootFolder&#125; $&#123;rootFolder&#125;$&#123;currTime&#125;\n rm -rf $&#123;rootFolder&#125;`, function (err, stream) &#123; if (err) throw err; stream.on('close', function (code, signal) &#123; // 在执行shell命令后，开始上传部署项目代码 spinner.start(); scpClient.scp( './dist', &#123; host: server.host, port: server.port, username: server.username, password: server.password, path: server.path &#125;, function (err) &#123; spinner.stop(); if (err) &#123; console.log(chalk.red('Fail! 发布失败.\n')); rl.close(); throw err; &#125; else &#123; console.log(chalk.green('Success! 成功发布到' + server.host + '服务器! \n')); rl.close(); &#125; &#125; ); conn.end(); &#125;) &#125;); &#125;) .on('error', function (err) &#123; console.log(chalk.red('Fail! 服务器连接失败.\n')); rl.close(); throw err; &#125;) .connect(&#123; host: server.host, port: server.port, username: server.username, password: server.password &#125;);&#125; OK，在这里我们通过配置文件里的path来动态获取根目录和根文件夹，执行备份命令后再进行文件上传！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习期间作品（部分）]]></title>
    <url>%2F2020%2F03%2F08%2FworkExpress%2F</url>
    <content type="text"><![CDATA[实习（实习公司：Testbird）期间的部分作品展示！实习期间独立负责兼容/场景测试在线报告从零开始开发到最终上线，目前已经上线运行6+个月！在线演示地址1：兼容/场景测试在线报告—–手游测试在线报告 1.兼容/场景测试在线报告演示地址：演示报告 进入公司后直接开始开发的一个新项目，主要是用于展示APP测试的结果，反馈给客户。 技术栈Vue+Vuex+axios+Echarts，使用vue的全家桶进行开发，webpack进行打包，Jenkins进行项目部署！ 项目概述 包含总体概况、汇总报告页、问题报告页、终端报告页、性能报告页、机型详细页、测试步骤页等； 根据公司自动化测试平台返回的测试结果进行图表化展示测试结果，方便用户能够更加直观的查看测试结果； 该项目是直接面向用户的产品，开发周期在两个月，测试一周，经过两个半月成功上线； 项目不停迭代，后续添加了历史对比、报表系统等新需求； 部分截图 2.手游测试报告演示地址：演示报告 选用vue框架进行重构原有项目，其主要优点在于： 简单易上手，官方文档较为完善，社区讨论可圈可点； 整洁的代码和模块，提高了编程效率； 脱胎于ng，没有过多复杂的逻辑； 可维护性高； 重构效果 优化H5标签，更富语义化； 代码项目结构更加轻便，便于阅读理解； 展示方面，数据通过vuex进行管理； 页面重新设计，更富表现形式； 渲染上比ng更高效； 优化内容报告 首次进入即写入相关信息至本地浏览器，使URL地址更为轻便简洁； 首页四大模块，报告关键数据一目了然，进入即可查看相关详情信息； 图表利用丰富，数据可视化更直观； 渲染更加高效，浏览速度提升明显，有效利用缓存，大幅降低减少请求时间； 结构更加清晰，层次分明，设计自带返回按钮，跳转更加方便； 快速问题定位，设备定位； 错误日志等级筛选正向筛选，单看一级更加方便； 部分截图 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>作品</category>
      </categories>
      <tags>
        <tag>作品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的常用的API总结，绝对实用，处理数据更加快捷方便]]></title>
    <url>%2F2018%2F10%2F20%2FarrApi%2F</url>
    <content type="text"><![CDATA[数组相关常用API,熟悉这些常用的API，在实际开发中能够提高很大的开发效率！ 1.遍历数组arr.forEach(function (el,index,event) { console.log(el)//每一个元素 console.log(index)//序号 console.log(event)//数组本身}) 2.数组过滤，.filter(回调函数);返回的是符合条件的筛选后的数据,组成的新数组 3个参数–数组元素、索引、该数组 var arr=[10,20,30,40,50,60]; var result=arr.filter(function(el,index,event){ return x&gt;30; }); console.log(result);//result为返回满足条件的新数组 3.遍历数组，每个元素都满足条件，才返回true every方法,每个元素都要满足条件才为true var arr=[100,200,300,400,500]; var result=arr.every(function(x,y,z){ return x&gt;99; }); console.log(result); 4.遍历数组，只要有一个元素满足就返回truesome方法,只要有一个元素满足条件就是true var arr=[10,20,30,40,50]; var result=arr.some(function(x,y,z){ return x&gt;40; }); console.log(result); 5.map方法,设置数组中的元素都执行一次函数,把新的数组存储在一个新的数组中var arr=[10,20,30,40,50]; var result=arr.map(function(x,y,z){ return x*2; }); console.log(result);//[20,40,60,80,100] 6.数组转字符串 var arr=[“小明”,”小李”,”小王”,”小张”]; var result=arr.join(“,”);//可增加连接符 console.log(result); 7.截取字符串 .slice(开始索引,结束索引);截取原数组中的数据,然后组成一个新的数组var arr=[1,2,3,4,5,6,7,8,9]; var result=arr.slice(0,5); // 0到5之间（不包括5） console.log(result); var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序入门（二）之常用语法]]></title>
    <url>%2F2018%2F10%2F17%2FweChatTwo%2F</url>
    <content type="text"><![CDATA[微信小程序中常用的组件、技巧、前后端请求数据等，这一章的学习便能开发一个简易的小程序。 常用组件通过上一篇博客的学习，开发微信小程序的基本结构已经搭建好啦，现在可以开始编写代码，开始开发啦。 view、text、image、input、radio 这几个是比较常见的，用得比较多的组件，更多的组件可参考官方文档。 其实这些组件和HTML中的标签差不错，比如view就好比HTML中的div，text就好比span等等。 获取js中数据如何从js中获取数据到页面中渲染，这是在开发中用得很多的。微信中使用 `{{}}` 进行获取js中的数据，例如：index.js:123data: &#123; name:'咕噜先森'&#125; index.wxml:1&lt;view&gt;&#123;&#123;name&#125;&#125;&lt;/view&gt; 获取前端页面中的数据例如获取input中输入的数据，使用bindinput绑定函数，并在函数中使用事件对象e.detail.value进行获取值。例如：index.wxml:1&lt;input type='text' bindinput='getValue'&gt;&lt;/input&gt; index.js:123getValue: function (e) &#123; console.log(e.detail.value)&#125;, 设置数据对从前端页面获取到的值，怎样保存到数据中，供后面的逻辑使用。this.setData({})index.wxml:1&lt;input type='text' bindinput='getValue'&gt;&lt;/input&gt; index.js:12345678data: &#123; name:'' &#125;,getValue: function (e) &#123; this.setData(&#123; name: e.detail.value &#125;)&#125;, 循环遍历数据假如js中拿到的数据是一个数组，应该怎样将全部的数据渲染在页面中？wx:for,例如：（其中list为一个数组） 1234567&lt;block wx:for="&#123;&#123;list&#125;&#125;" wx:key="&#123;&#123;goodsId&#125;&#125;"&gt; &lt;view class="tr bg-g" wx:if="&#123;&#123;index % 2 == 0&#125;&#125;"&gt; &lt;view class="td"&gt;&#123;&#123;item.goodsId&#125;&#125;&lt;/view&gt; &lt;view class="td"&gt;&#123;&#123;item.goodsName&#125;&#125;&lt;/view&gt; &lt;view class="td"&gt;&#123;&#123;item.goodsPrice&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/block&gt; 绑定数据在前端开发时，绑定是一个事件可以使用onclick等进行绑定，但是小程序不是这样使用的，而是使用bindtap 1&lt;view bindtap=“submit”&gt;提交&lt;/view&gt; 向后台发送请求前后端的数据交互，是在进行开发时不可缺少的，比如ajax进行请求，微信中使用wx.request进行请求。 1234567891011121314151617wx.request(&#123; url: 'test.php', //接口地址 data: &#123; //发送的数据 name:'咕噜先森' &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, method:'GET/POST',//发送的方法 success: function(res) &#123;//请求成功调用的函数 console.log(res.data) &#125;, fail: function () &#123;//请求失败调用的函数 console.log("接口调用失败"); &#125; &#125;) 其他常用结构 向数组中追加数据 1arr.push() 循环遍历数组 123for(var i=0;i&lt;arr.length;i++)&#123; &#125; 循环对象 123for(var name in json)&#123; &#125; 结束到目前为止，小程序的基本的入门介绍完啦，后续会继续更出更多的分享或者小程序的实例。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序入门（一）之开发工具介绍]]></title>
    <url>%2F2018%2F10%2F06%2FweChat%2F</url>
    <content type="text"><![CDATA[什么是小程序英文名 mini program,一种崭新的应用程式。2016年张小龙（微信创始人）提出微信应用号，当时他的描述是，小程序是一种不需要下载安装即可使用的应用，他实现了应用触手可及的梦想，用户扫一扫或者搜一下即可打开应用，也体现了用完即走的理念，用户不用关心是否安装太多应用的问题，应用无处不在，随时可用，但又无序安装卸载。因为苹果公司告了所以改名微信小程序。2017年年初，给用户开放了入口。但是只能企业，后面对个人开放了。目前比较火爆的微信小程序，跳一跳之类的。官网：mp.weixin.qq.com 录制视频（可全屏观看）本视频为随堂录制视频，与博客内容一致，若看博客不懂的可以看录制的视频。 资源下载PPT下载：PPT源码下载：商品收银系统源码下载 开发准备工作注册小程序账号，利用微信号注册即可，注册地址为：戳这儿 小程序开发者工具下载，下载地址为：戳这儿 开发工具介绍 开发者工具分为四个部分：模拟器，编辑器，调试器，工具栏 模拟器：当我们保存了编辑的代码，就可以直接在模拟器中看到效果 编辑器：小程序所有的开发代码都可以在这里修改。 调试器：继承了许多调试小程序需要的功能 工具栏：用于编译，预览小程序的源代码 项目搭建 1、选择在本地创建的项目目录 2、填写AppID 查找AppID，登录小程序官网官网：mp.weixin.qq.com-&gt;设置-&gt;开发设置-&gt;AppID 项目目录介绍 |–pages |--每个页面(index) //在pages文件夹中，每一个页面都是有个文件夹 index.js index.wxml index.wxss index.json |--utils app.js app.json app.wxss project.config.json //工程配置文件 描述整个项目的参数 1、pages:放所有页面的文件夹，此目录下的每一个文件夹代表一个页面，那咱们的项目两个页面就两个文件夹 2、每个页面包含四个文件 .wxml文件是界面文件， ----&gt;html .js是事件交互文件，用于处理界面的点击事件等功能； ---&gt;js .wxss为界面美化文件，让界面显示的更加美观； ---&gt;css .json为配置文件，用于修改导航栏显示样式等，小程序每个页面必须有.wxml和.js文件， 其他两种类型的文件可以不需要。 3、util：该文件件主要用于存放全局的一些.js文件，公共用到的一些事件处理代码文件可以放到该文件夹下， 用于全局调用。 4、app.js : 系统的方法处理文件，主要处理程序的声明周期的一些方法；例如：程序刚开始运行时事件处理等 5、app.json : 系统全局配置文件，设置导航头的颜色，字体大小，下面有没有tabbar等功能，具体页面的配置在页面的json文件中单独修改； 6、app.wxss : 全局的界面美化代码 7、project.config.json 通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置.考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 project.config.json， app.jsApp() 注册一个小程序，整个的app在整个小程序里面只会调用一次，整体是一个app，app下面有很多page，在这个app里面配置的东西，在每个页面都可以使用 onLaunch 函数类型 声明周期函数-监听小程序初始化，全局只会触发一次 globalData：全局的数据 app.jsonpages 接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的[路径+文件名]信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。 注：文件名不需要写文件后缀，因为框架会自动去寻找路径下 .json, .js, .wxml, .wxss四个文件进行整合。 如果添加后缀报错。 windows 小程序所有页面的顶部背景颜色，文字颜色定义在这里的 “backgroundTextStyle”:”light”, //下拉 loading 的样式，仅支持 dark/light “navigationBarBackgroundColor”: “#fff”, //导航栏背景颜色，如”#000000” 颜色值最好不要写单词，十六进制也不要简写 “navigationBarTitleText”: “WeChat”, //导航栏标题文字内容 “navigationBarTextStyle”:”black” //导航栏标题颜色，仅支持 black/white Page配置 “pages”:[ “pages/index/index”, “pages/center/center” ], 在tabBar里面进行设置的路由，将会固定在页面的底部。 头部配置 “window”:{ “backgroundTextStyle”:”light”, “navigationBarBackgroundColor”: “#fff”, “navigationBarTitleText”: “WeChat”, “navigationBarTextStyle”:”black” } 路由配置“tabBar”: { “list”: [ { “pagePath”: “pages/index/index”, “text”: “首页”, “iconPath”:”img/index.png”, //默认的图标 “selectedIconPath”:”img/linghtZB.png” //选中后的图标 }, { “pagePath”: “pages/center/center”, “text”: “个人中心”, “iconPath”: “img/center.png”, “selectedIconPath”: “img/center.png” } ] } 结束微信小程序的介绍以及小程序开发工具以及具体的配置信息都已经分享完了，了解了这些就可以开始小程序的开发啦。常用的标签及语法见下一期博客啦^_^ var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装 | Node连接MySQL并封装其增删查改]]></title>
    <url>%2F2018%2F05%2F17%2Fnode-mysql%2F</url>
    <content type="text"><![CDATA[Node连接Mysql说到node，可能大家会想到MOngoDB作为数据库，这里将会介绍node与mysql的连接，并分享了封装好的实例代码，在项目开发中可直接使用。下一篇博客将会讲node连接MongoDB。 安装Mysql模块1npm install mysql 连接Mysql1234567891011121314151617const mysql = require('mysql');let connection = mysql.createConnection(&#123; host : 'localhost', user : 'root', password : 'password', database : 'test'&#125;);connection.connect(function(err) &#123; if (err) &#123; console.error('连接失败: ' + err.stack); return; &#125; console.log('连接成功 id ' + connection.threadId);&#125;); host：连接的服务器user：数据库用户名password：设置的MySQL密码database： 要连接的数据库名 常用的SQL语句具体的使用这里不做详细说明，包括select、insert、update、delete等语句。 Node操作Mysql查询 123456connection.query('SELECT * FROM t_user WHERE username = "whg"', (err, results, fields) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 添加 123456connection.query('INSERT INTO t_user(username, pass) VALUES(?, ?)',['whg', '123'], (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 删除 123456connection.query('DELETE FROM t_user WHERE id = 1', (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 更新 123456connection.query('UPDATE t_user SET pass = "321" WHERE username = "whg"', (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 结束连接 1234connection.end(function(err) &#123; &#125;);connection.destroy(); 这两种都行，第二种是强制结束。 封装说了这么多，感觉操作起来还是挺简单的。在实际开发中，我们想要操作起来更方便，那就让我们自己封装一下来使用。直接上代码： 封装好的代码1.数据库配置文件12345678//配置链接数据库参数module.exports = &#123; host : 'localhost', port : 3306,//端口号 database : 'nodetest',//数据库名 user : 'root',//数据库用户名 password : '123456'//数据库密码&#125;; 2.封装、暴露方法12345678910111213141516171819202122232425262728293031323334let mysql = require('mysql');//引入mysql模块var databaseConfig = require('./mysql.config'); //引入数据库配置模块中的数据//向外暴露方法module.exports = &#123; query : function(sql,params,callback)&#123; //每次使用的时候需要创建链接，数据操作完成之后要关闭连接 var connection = mysql.createConnection(databaseConfig); connection.connect(function(err)&#123; if(err)&#123; console.log('数据库链接失败'); throw err; &#125; //开始数据操作 //传入三个参数，第一个参数sql语句，第二个参数sql语句中需要的数据，第三个参数回调函数 connection.query( sql, params, function(err,results,fields )&#123; if(err)&#123; console.log('数据操作失败'); throw err; &#125; //将查询出来的数据返回给回调函数 callback &amp;&amp; callback(results, fields); //results作为数据操作后的结果，fields作为数据库连接的一些字段 //停止链接数据库，必须再查询语句后，要不然一调用这个方法，就直接停止链接，数据操作就会失败 connection.end(function(err)&#123; if(err)&#123; console.log('关闭数据库连接失败！'); throw err; &#125; &#125;); &#125;); &#125;); &#125;&#125;; 3.演示实例123456789101112var db=require('../model/mysql.js');// 查询实例db.query('select * from t_user', [],function(result,fields)&#123; console.log('查询结果：'); console.log(result);&#125;);//添加实例var addSql = 'INSERT INTO websites(username,password) VALUES(?,?)';var addSqlParams =['咕噜先森', '666'];db.query(addSql,addSqlParams,function(result,fields)&#123; console.log('添加成功')&#125;) 结束想要使用的朋友，可以直接把封装好的两个文件copy到项目中，改一下配置就可以使用了，大大提高开发效率。下一篇将会分享Node连接MongoDB。 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【零开始】怎样购买、配置服务器及发布网站（页）？]]></title>
    <url>%2F2018%2F05%2F15%2FwebService%2F</url>
    <content type="text"><![CDATA[本文主要讲解从零开始搭建属于自己的服务器，购买==&gt;配置==&gt;发布，这么一系列详细流程，让自己做的网页能够发布到网络上，一起来开启服务器之旅！本文主要以腾讯云学生套餐进行讲解，其他的云服务器操作类似。若对你有帮助的话，希望能够坚持做下去。 本文原创首发：咕噜先森的博客 购买服务器服务器目前使用得最多的是阿里云和腾讯云，用起比较稳定。这里讲解的是腾讯云，其实很多浏览器的配置和使用都差不多。这里演示的是腾讯云的学生套餐，作为学生狗，在校期间用用免费的就行。进入腾讯云云+校园服务计划，选择【体验版】(PS:每日零点开始抢，每天100个名额，限额抢购，抢！抢！)套餐，10元/月。 选择配置腾讯云免费学生套餐 【1核2G，1M带宽 50G云硬盘】，这是腾讯云学生套餐默认的配置，不能进行选择。接下来选择服务器其他的配置选项： 地域：即服务器的位置。选择离访问者比较近的服务器的区域就行，越近的话访问的速度相对会快一点。【例如：成都】 可用区：根据地域进行选择就行，问题不大。【例如：成都一区】 操作系统：有Linux、Windows等系统，Linux又包括不同的版本：CentOS、Debian、Ubuntu等。选择一个自己熟悉的系统就行。【例如：Windows Server】 系统版本：根据你选择的操作系统进行选择适合自己的版本。【例如：Windows Server 2012 R2 标准版 64位中文版】 购买时长：选择一个月，因为腾讯云的学生套餐的优惠券是每个月进行领取，所以只能一个月一个月进行购买。 对象存储：使用默认的50G就好。 域名服务：第一年免费使用.cn域名。若自己有域名，可以选择【否】，若没有可以选择【是】，然后输入一个自己想要的域名，但是这个域名必须是全球唯一的，所以可能你想要的域名已经被注册了，那么你就只能注册其他的域名了。 核对信息核对信息，查看自己的购买的配置是否是自己需要的配置。支付完订单，那么你的服务器就已经到手了，就可以开始撸自己的服务器了。 查看服务器那么如何查看自己已经买好的服务器呢。登录腾讯云，进入控制台管理，点击导航栏【云产品】==&gt;【云服务器】==&gt;【云主机】，便能查看自己的云主机啦。此处可以查看云主机的各种状态以及一些操作，其中可以查看自己的公网IP和内网IP。 服务器备案与域名解析严格意义上来讲域名备案的目的就是为了防止在网上从事非法的网站经营活动，打击不良互联网信息的传播，如果网站不备案的话，7天后将会关停服务器，导致不能正常使用。目前国内的所有服务器都需要进行备案。在这里，直接引用腾讯云给出的备案官方文档，很详细，参照着备案就行，从开始备案到完成的时间可能在20天左右。域名解析即将域名与IP绑定起来，通过DNS解析，便能通过域名访问IP对应的网站。详细的域名解析见这篇博客PS：《服务器备案与域名解析》这一步可以先跳过，把后面的步骤全部搞通了再来处理这一模块也是可以的。 登录云主机登录云主机便可以操作整个云服务，并配置成你想要的样子。点击【登录】便可查看如何进行登录，根据不同的系统选择不同的登录方式。登录步骤（Windows）： 快捷键【win+R】，输入“mstsc”命令，打开远程桌面对话框。 输入框输入云主机的公网IP地址，点击连接。 输入默认的用户名【Administrator】，同时输入自己购买服务器时设置的密码，点击确定便能连接到远程桌面。 注意：连接时记得在网速好的时候，否则可能带不动导致连接不上。进入云主机过后，大家会发现和我们平时使用的Windows没什么区别，操作起来就简单多了。 开启服务器好了，到了这一步离成功已经很近了。怎样才能让我们的服务器跑起来，能够运行我们自己写的网页或者网站。那么你需要准备下面这个软件——PHPStudy，其实开启服务器的很多，比如Tomcat，只是这里是使用PHPStudy进行演示。PHPStudy下载地址，下载后进行傻瓜式的安装即可。安装好后，正常启动服务器的效果如下图所示(即前面是绿色小圆点而不是红色小圆点)。这里我们只需要管Apache即可，不用管Mysql，当然若你的项目需要数据库，那么肯定是需要进行相关配置的。Apache默认端口为80，若不使用80端口的话，那么在使用ip地址或者域名访问的时候需要在其后添加端口号。MySQL默认端口为3306。若不能正常启动，说明端口被占用，这是需要终止其他占用该端口的进程即可。启动过后，需要简单的配置一下端口及目录。操作步骤：点击【其他选项菜单】==&gt;【打开配置文件】==&gt;【vhosts-conf】此时打开应该是空的，只需要把下面的配置添加进去即可。 12345678910&lt;VirtualHost _default_:80&gt;DocumentRoot "C:\phpstudy\WWW" &lt;Directory "C:\phpstudy\WWW"&gt; Options +Indexes +FollowSymLinks +ExecCGI AllowOverride All Order allow,deny Allow from all Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; PS：记得修改自己的根目录的位置。那么我的网页应该放在哪个文件夹下才能被访问呢？这时需要打开网站的根目录。打开根目录的步骤:点击【其他选项菜单】==&gt;点击【网站根目录】，如下图所示：打开后的文件夹便是网站的根目录，这时文件夹中有一些文件是PHPAdmin的一些文件，这时在浏览器地址栏中输入localhost或者127.0.0.1便能访问到PHPAdmin的主页，到此说明phpstudy能够正常开启服务了。以后上传的网页就需要上传到这个文件夹下，就能正常访问了。若在当前目录有index.html，那么直接访问ip地址或者域名，打开的网页便是默认的index.html。如想访问非默认缺省主页，需要在ip或域名后添加该文件的相对路径。 【例如】在WWW下有一个文件夹aaa中有一个文件aaa.html,那么这时候需要在浏览器地址栏中输入ip地址/aaa/aaa.html（119.149.78.109/aaa/aaa.html）配置好后，你的服务器便跑起来了，你便能访问你配置好的目录下的网页了，同时也可以使用ip地址进行访问。 这里只做了简单的开启服务器的功能，更多详细的关于phpstudy的使用可参考官网给出的一篇文章 如何上传文件到服务器所有的环境都搭好了，那么应当怎样将我们自己做好的网页放在服务器上呢？这里讲解三种方法供读者参考，读者可选择适合自己的方法。 方法一想必大家都使用过ftp进行上传文件，对，这里就是需用ftp进行上传文件。那么上传之前你需要做一个准备工作，那就是在云服务器上配置ftp。这里需要在云主机上安装一个软件【FileZilla Server】，官网下载地址。安装方式也是和phpstudy一致，傻瓜式安装即可。安装好后，打开软件点击【File】启动FileZilla Server。 设置ftp账号点击【Edit】==&gt;【Users】点击【Add】按钮进行添加账户，同时填写账户的名称【例如：test】 设置密码在【Password】选项前打勾，并输入密码即可。 选择共享的文件夹如下图所示，点击【1】==&gt;点击【Add】选择想要共享的文件夹，这里可直接选择phpstudy的根目录，这样上传的文件夹可直接访问。图中第3步便是设置这个添加的账户对当前目录的文件和文件夹的权限，有增、删、改、查，可根据需求进行设置，若是自己使用可全部勾选上。后面两项可以不用设置，直接使用默认的即可。 到此为止，云服务器上的ftp已经配置完成，现在可直接在本机电脑上通过ftp软件或者资源管理器使用刚刚设置好的用户和密码进行登录，然后便能上传文件了。例如使用【资源管理器】进行登录上传。打开【我的电脑】，在地址栏中输入：【ftp:IP地址】，这时会弹出一个登录框，要求输入账号和密码，输入刚刚添加的账号和密码即可。这时便登录进来了，直接把要上传的文件拖进来或者复制进来就能完成上传了。例如上传一个hello.html文件到服务器，直接把hello.html拖拽进去或者复制进去就OK了。下图是为上传hello.html之前的情况：下图是为上传完成hello.html的情况：这时，我们在云服务器上打开对应的那个目录，便能查看到刚刚那个hello.html文件了。这时我们在浏览器地址栏中输入IP地址+hello.html便能访问到hello.html文件中的内容了。这种方法是使用得比较多的，当然使用ftp软件是一样的，只要配置好后使用起来还是很简单的。 方法二登录进入云服务器过后，直接通过复制粘贴进行上传文件。但是有一个弊端是，若文件过大很容易造成上传失败。 方法三在云服务器中直接绑定本机电脑上的某一个磁盘，这样就可以将本机的文件绑定在云服务器上，再通过复制粘贴便能轻松完成文件的上传。 结语通过这些详细的步骤，我相信你已经从零搭建起自己的服务器了，享受了这么一个过程。过程很重要，当然结果做出来了还是很有成就感的。当然，由于作者一个人经历、水平也有限，本文中肯定有一些错误，很希望大家提出意见与建议，可以在文末进行留言，作者将会进一步进行改进。码字也不容易啦，如果你觉得本文对自己有帮助，可以在博客文章下面打赏一点棒棒糖零花钱，多少随意啦^_*_^ var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法详解】冒泡/选择/插入/快速排序详解·JS实现]]></title>
    <url>%2F2018%2F04%2F19%2Fsort%2F</url>
    <content type="text"><![CDATA[最近再深入了解了一下排序算法，大概总结了一下，直接在代码中一行一行的进行注释。算法思路==&gt;实现代码==&gt;代码详细注释==&gt;演示过程，带来更加直观的理解。所有的代码可直接运行，查看结果。 冒泡排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;冒泡排序&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //swap是交换数组内位置的函数 function swap(_arr, index1, index2) &#123; const arr = _arr; arr[index1] += arr[index2]; arr[index2] = arr[index1] - arr[index2]; arr[index1] -= arr[index2]; &#125; // 基本思路： // 前一项(i)与后一项(i+1)项比较，如果前一项比后一项大就交换这两项； // 重复这个过程到最后； // 一趟完成后再从头开始重复上面的步骤，有多少项就要重复几次。 function bubbleSort(_arr) &#123; const arr = [].slice.call(_arr); const len = arr.length; for (let i = 0; i &lt; len; i += 1) &#123; for (let f = 0; f &lt; len - 1; f += 1) &#123; // 相邻两个元素进行比较 if (arr[f] &gt; arr[f + 1]) &#123; // 交换位置 swap(arr, f, f + 1); &#125; &#125; &#125; return arr; &#125; console.log(bubbleSort([2, 5, 4, 7, 3])) // 演示过程 // // 初始 // 5 4 9 5 3 // // 第一趟 // 4 5 9 5 3 // 5&gt;4，交换 // ^ ^ // 4 5 9 5 3 // 5&lt;9，不变 // ^ ^ // 4 5 5 9 3 // 9&gt;5，交换 // ^ ^ // 4 5 5 3 9 // 9&gt;3，交换 // ^ ^ // // 第二趟 // 4 5 5 3 9 // 4&lt;5，不变 // ^ ^ // 4 5 5 3 9 // 5=5，不变 // ^ ^ // 4 5 3 5 9 // 5&gt;3，交换 // ^ ^ // 4 5 3 5 9 // 5&lt;9，不变 // ^ ^ // // 第三趟 // 4 5 3 5 9 // 4&lt;5，不变 // ^ ^ // 4 3 5 5 9 // 5&gt;3，交换 // ^ ^ // 4 3 5 5 9 // 5=5，不变 // ^ ^ // 4 3 5 5 9 // 5&lt;9，不变 // ^ ^ // // 第四趟 // 3 4 5 5 9 // 4&gt;3，交换 // ^ ^ // 3 4 5 5 9 // 4&lt;5，不变 // ^ ^ // 3 4 5 5 9 // 5=5，不变 // ^ ^ // 3 4 5 5 9 // 5&lt;9，不变 // ^ ^ // // 第五趟 // 3 4 5 5 9 // 3&lt;4，不变 // ^ ^ // 3 4 5 5 9 // 4&lt;5，不变 // ^ ^ // 3 4 5 5 9 // 5=5，不变 // ^ ^ // 3 4 5 5 9 // 5&lt;9，不变 // ^ ^ // // 结果 // 3 4 5 5 9 // 改进方案 // 通过上面的排序过程，可以发现其实每一趟就可以确定最后一位的位置了， // 所以可以不用再比较最后的位置。代码改造也很小，只要在内循环减去已经确定的位置数即可。 function modifiedBubbleSort(_arr) &#123; const arr = [].slice.call(_arr); const len = arr.length; for (let i = 0; i &lt; len; i += 1) &#123; // 每一趟便能确定最后一个数，所以可以减少一些不必要的比较 for (let f = 0; f &lt; len - i - 1; f += 1) &#123; if (arr[f] &gt; arr[f + 1]) &#123; swap(arr, f, f + 1); &#125; &#125; &#125; return arr; &#125; console.log(modifiedBubbleSort([2, 5, 4, 7, 3])) // 演示过程 // 5 4 9 5 3 // // 第一趟 // 4 5 9 5 3 // 5&gt;4，交换 // ^ ^ // 4 5 9 5 3 // 5&lt;9，不变 // ^ ^ // 4 5 5 9 3 // 9&gt;5，交换 // ^ ^ // 4 5 5 3 9 // 9&gt;3，交换 // ^ ^ // // 第二趟 // 4 5 5 3 9 // 4&lt;5，不变 // ^ ^ // 4 5 5 3 9 // 5=5，不变 // ^ ^ // 4 5 3 5 9 // 5&gt;3，交换 // ^ ^ // // 第三趟 // 4 5 3 5 9 // 4&lt;5，不变 // ^ ^ // 4 3 5 5 9 // 5&gt;3，交换 // ^ ^ // // 第四趟 // 3 4 5 5 9 // 4&gt;3，交换 // ^ ^ // // 结果 // 3 4 5 5 9 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 插入排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;插入排序&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //swap是交换数组内位置的函数 function swap(_arr, index1, index2) &#123; const arr = _arr; arr[index1] += arr[index2]; arr[index2] = arr[index1] - arr[index2]; &#125; // 插入排序就是要把后面的数往前面插入。假定第一项已经排序了，接着从第二项开始，依次判断当前项应该插入到前面的哪个位置。 // 基本思路： // 1.从第二项开始(i=1)，当前项(i)，缓存其值和位置； // 2.向前遍历，指针f初始化为i位置，如果f-1大于当前项的值，则交换f和f-1（即f-1向后移动一位），并f--； // 3.如果遇到f-1小于当前值，或f=0时停止循环，这时候f即是当前项的位置，将之前的缓存值写入该位置。 function insertionSort(_arr) &#123; const arr = [].slice.call(_arr); const len = arr.length; // 从第2个元素开始和前面的元素比较，取到最后一个元素完 for (let i = 1; i &lt; len; i += 1) &#123; let f = i; // 获取到当前要比较元素的值 const temp = arr[i]; // 遇到f-1小于当前值，或f=0时停止循环 while (f &gt; 0 &amp;&amp; arr[f - 1] &gt; temp) &#123; // 值更大的那一个元素向后移动,即当前比较的元素向前插入 arr[f] = arr[f - 1]; f -= 1; &#125; // 这时候f即是当前项的位置，将之前的缓存值写入该位置 arr[f] = temp; &#125; return arr; &#125; console.log(insertionSort([2, 5, 4, 7, 3])) // // 演示过程 // 5 4 9 5 3 // // 第一趟，当前项是1号位，数字4 // _ 5 9 5 3 // 4&lt;5，5向后移动 // ^ ^ // 4 5 9 5 3 // 遍历结束，写入4 // ^ // // 第二趟，当前项是2号位，数字9 // 4 5 9 5 3 // 9&gt;5，不变 // ^ // 4 5 9 5 3 // 9&gt;4，不变，遍历结束 // ^ // // 第三趟，当前项是3号位，数字5 // 4 5 _ 9 3 // 5&lt;9，9向后移动 // ^ ^ // 4 5 _ 9 3 // 5=5，不变 // ^ // 4 5 _ 9 3 // 5&gt;4，不变 // ^ // 4 5 5 9 3 // 遍历结束，写入5 // ^ // // 第四趟，当前项是4号位，数字3 // 4 5 5 _ 9 // 3&lt;9，9向后移动 // ^ ^ // 4 5 _ 5 9 // 3&lt;5，5向后移动 // ^ ^ // 4 _ 5 5 9 // 3&lt;5，5向后移动 // ^ ^ // _ 4 5 5 9 // 3&lt;4，4向后移动 // ^ ^ // 3 4 5 5 9 // 遍历结束，写入3 // ^ // // 结果 // 3 4 5 5 9 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 选择排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;选择排序&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //swap是交换数组内位置的函数 function swap(_arr, index1, index2) &#123; const arr = _arr; arr[index1] += arr[index2]; arr[index2] = arr[index1] - arr[index2]; arr[index1] -= arr[index2]; &#125; // 选择排序算法是一种原址比较排序算法。这也是比较简单的过程，只要不断遍历找到最小的数依次放入位置即可。 // 基本思路： // 1.设定一个指针指向最小的数，从0号位开始； // 2.遍历数据，如果遇到比当前指针指向的数还小的数，就将指针重新指向这个新位置； // 3.遍历完成即得到了最小的数的位置，把0号位与这个位置的数交换； // 4.接下来就是1号位，重复以上步骤直到全部位置都正确 function selectionSort(_arr) &#123; const arr = [].slice.call(_arr); const len = arr.length; // 从0号位开始遍历，只取到倒数第二个值 for (let i = 0; i &lt; len - 1; i += 1) &#123; // 选定指针的位置，依次作为指针的指向 let indexMin = i; // 从第二个元素开始进行比较,取到最后一个元素 for (let f = i + 1; f &lt; len; f += 1) &#123; // 如果当前的元素比指针位的元素小，则把小的那个值赋值给indexMin if (arr[indexMin] &gt; arr[f]) &#123; indexMin = f; &#125; &#125; // 如果指针的位置换了位置，即不等于原始i的值，则交换位置 if (indexMin !== i) &#123; swap(arr, indexMin, i); &#125; &#125; return arr; &#125; console.log(selectionSort([2, 5, 4, 7, 3])) // 实例过程 // 5 4 9 5 3 // // 第一趟，指针指向0号位 // 5 4 9 5 3 // 4&lt;5，指针指向1号位 // ^ // 5 4 9 5 3 // 9&gt;4，指针不变 // ^ // 5 4 9 5 3 // 5&gt;4，指针不变 // ^ // 5 4 9 5 3 // 3&lt;4，指针指向4号位 // ^ // 3 4 9 5 5 // 遍历结束，交换0号位和4号位 // // 第二趟，指针指向1号位 // 3 4 9 5 5 // 9&gt;4，指针不变 // ^ // 3 4 9 5 5 // 5&gt;4，指针不变 // ^ // 3 4 9 5 5 // 5&gt;4，指针不变 // ^ // 3 4 9 5 5 // 遍历结束，1号位不变 // // 第三趟，指针指向2号位 // 3 4 9 5 5 // 5&lt;9，指针指向3号位 // ^ // 3 4 9 5 5 // 5=5，指针不变 // ^ // 3 4 5 9 5 // 遍历结束，交换2号位和3号位 // // 第四趟，指针指向3号位 // 3 4 5 9 5 // 5&lt;9，指针指向4号位 // ^ // 3 4 5 5 9 // 遍历结束，交换3号位和4号位 // // 结果 // 3 4 5 5 9 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;快速排序&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 快速排序的思想跟归并很像，都是分治方法，但它没有像归并排序那样将它们分割开，而是使用指针游标来标记，每次会确定一个参考数的位置。稍微会比前面的复杂一些。 // 基本思路： // 1.取数组的第0项作为参考数，缓存0号位的数。 // 2.设定一个从0号位开始的low指针，一个从末尾开始的high指针； // 3.先从high指针开始移动，指针指向的数与参考数做比较，如果大于或等于参考数则继续向前移动，如果小于参考数则停下并把high指针指向的数替换到当前low指针指向的位置； // 4.再从low指针开始移动，指针指向的数与参考数做比较，如果小于或等于参考数则继续向后移动，如果大于参考数则停下并把low指针指向的数替换到当前high指针指向的位置； // 5.如此循环交替移动两个指针，直到low指针的指向位高于或等于high的指向位； // 6.至此low指向位即是参考数的位置pivotloc，将参考数写入low指向的位置； // 7.以此位置pivotloc为分割，在左右两边重复上述的步骤，直到排序完成。 function quickSort(_arr) &#123; const arr = [].slice.call(_arr); function partition(low, high) &#123; // 首先设置一个参考的数，一般是以第一个数为参考数 const pivotkey = arr[low]; // 定义最左边的指针和定义最右边的指针 let i = low; let j = high; // 当i和j还没相遇的时候就一直循环 while (i &lt; j) &#123; // i&lt;j且数都比参考数大的时候从右往左找，找到比参考数pivotkey小的数 while (i &lt; j &amp;&amp; arr[j] &gt;= pivotkey) &#123; j -= 1; &#125; // 找到了比参考数小的数就停止下来，然后就该从左边开始找了 arr[i] = arr[j]; // // i&lt;j且数都比参考数小的时候从左往右找，找到比参考数pivotkey大的数 while (i &lt; j &amp;&amp; arr[i] &lt;= pivotkey) &#123; i += 1; &#125; // 找到了比参考数大的数就与右边找到的比参考数小的那个数进行交换位置，然后第一轮交换就结束了。然后继续又右边开始找，开始第二轮交换。 arr[j] = arr[i]; &#125; // 当i和j相遇的时候，这一次的所有交换就结束了。这时，将当前相遇的位置与参考数交换。 // 这时，参考数的左边都是比参考数小的数，右边都是比参考数大的数 arr[i] = pivotkey; return i; &#125; (function QSort(low, high) &#123; // 这时对两边的序列继续进行上面的操作，继续交换，进行排序， if (low &lt; high) &#123; const pivotloc = partition(low, high); // 左边的序列 QSort(low, pivotloc - 1); // 右边的序列 QSort(pivotloc + 1, high); &#125; &#125;(0, arr.length - 1)); return arr; &#125; console.log(quickSort([2, 5, 4, 7, 3])) // 演示过程 // 5 4 9 5 3 // // 第一趟，参考数为5 // 5 4 9 5 3 // high开始移动，3&lt;5，high停止 // ^L ^H // 3 4 9 5 3 // 将high指向数3写入到low位置 // ^L ^H // 3 4 9 5 3 // low开始移动，3&lt;5，继续前进 // ^L ^H // 3 4 9 5 3 // 4&lt;5，继续前进 // ^L ^H // 3 4 9 5 3 // 9&gt;5，low停止 // ^L ^H // 3 4 9 5 9 // 将low指向数9写入到high位置 // ^L ^H // 3 4 9 5 9 // high开始移动，9&gt;5，继续后退 // ^L ^H // 3 4 9 5 9 // high开始移动，5=5，继续后退 // ^L^H // 3 4 5 5 9 // 两指针重合，结束，确定参考数5的位置，写入 // * // // 第二趟，参考数为3 // 3 4 5 5 9 // high开始移动，4&gt;3，继续后退 // ^L^H* // 3 4 5 5 9 // 两指针重合，结束，确定参考数3的位置，写入 // * * // // 第三趟，参考数为4 // 3 4 5 5 9 // 两指针重合，结束，确定参考数4的位置，写入 // * * * // // 第四趟，参考数为5 // 3 4 5 5 9 // high开始移动，9&gt;5，继续后退 // * * * ^L^H // 3 4 5 5 9 // 两指针重合，结束，确定参考数5的位置，写入 // * * * * // // 第五趟，参考数为9 // 3 4 5 5 9 // 两指针重合，结束，确定参考数9的位置，写入 // * * * * * // // 结果 // 3 4 5 5 9 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快运用 | 入门体验小教程 | 快到飞起]]></title>
    <url>%2F2018%2F04%2F04%2FquickApp%2F</url>
    <content type="text"><![CDATA[什么是快运用 快应用是基于手机硬件平台的新型应用形态，标准是由主流手机厂商组成的快应用联盟联合制定。 快应用标准的诞生将在研发接口、能力接入、开发者服务等层面建设标准平台，以平台化的生态模式对个人开发者和企业开发者全品类开放。 快应用具备传统APP完整的应用体验，无需安装、即点即用。 详情可见快运用官网官网 前言2018年3月20日，小米、中兴、华为、金立、联想、魅族、努比亚、OPPO、vivo、一加，共十家手机厂商在北京联合召开快应用标准启动发布会，手机厂商与中国信息通信研究院、电信终端产业协会、中国软件行业协会及数百家知名移动互联网应用企业共襄盛举，共同见证移动应用新生态的到来。 感觉看起来很牛逼，小编也想去看看究竟是个什么玩意儿。通过小编到官网的一探究竟，发现和Vue.js很相似，不管是结构还是语法上都很类似。好吧，话不多少，随着小编一起去体验一把吧。 准备工作 这里的入门教程 一台安卓手机或者是模拟器 一台电脑 出发1.搭建环境【安装node.js】需安装6.0以上版本的NodeJS，请从NodeJS官网下载，推荐v6.11.3注意: 不要使用8.0.*版本．这个版本内部ZipStream实现与node-archive包不兼容，会引起报错这是官方推荐的版本 【安装工具hap-toolkit】通过npm仓库安装，在命令行中执行以下命令：npm install -g hap-toolkit在命令行中执行hap -V会输出版本信息表示hap-toolkit安装成功，注意V是大写。 【创建工程】新建一个文件夹，打开命令行，并cd到新建的文件夹目录下，进行初始化项目，执行以下命令：hap init YourProjectName【安装依赖】一定要cd到你初始化的项目目录下，不是当前目录哦npm install【编译项目】在项目文件夹下，执行以下命令：npm run build这是，可能会报如下的错 淡定，只需要执行一次 hap update –force 即可解决, 对包强制进行升级。 然后再执行npm run build进行编译便能成功，可以看到如下界面。 编译成功以后，工程项目会多处两个文件夹： build：存放编译后的页面js文件和素材 dist：存放编译打包生成的rpk压缩文件，这个rpk就是快应用的最终执行文件了。 【最后一步，预览项目】你的手机或者模拟器需要安装 快应用调试器 和 平台预览版 下载后用直接USB或者QQ传输安装到手机。注意，两个apk都要安装！平台预览版是模拟快应用的运行时环境的。 安装前面编译出来的rpk文件 方法一： 本地安装预览 将你的工程中/dist目录下编译产出的rpk文件，复制到手机文件系统中。打开手机上的“快应用调试器” 点击“本地安装” 选择手机文件系统前面复制进来的rpk文件，即可预览到你的快应用的界面。 方法二： 扫码预览在项目文件夹下运行以下命令npm run server服务器启动后会显示如下的二维码，打开手机上的“快应用调试器”，点击“扫码安装”，扫这个二维码即可安装快应用进行预览。 推荐使用方法一，方法二可能扫描识别不了二维码。 如果看到如下界面，表示你已经成功开启了【快运用】的大门了，可以愉快的开始学习快运用了。 OK,至此快运用的介绍就到这里了。如果感兴趣的可以到官网了解更多官方文档 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>快运用</category>
      </categories>
      <tags>
        <tag>快运用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教学视频 | git的基本命令使用教学视频]]></title>
    <url>%2F2018%2F04%2F01%2FgitLearnMovie%2F</url>
    <content type="text"><![CDATA[前言git是当今非常流行的版本控制管理器，在项目开发中使用得非常多。但是很多人去网上看着文章学习的时候总会出现一些大大小小的错误，导致操作失败。这是一个全程录制的教学视频，每一步都很详细，希望能够帮助到你并能够顺利的使用git。 视频中的git命令清单可以参看我的博客【Git 常用的基本命令】 演示视频（可全屏观看） git的基本命令123456789101112131415161718192021222324252627282930配置git config –global user.name “Your Name”git config –global user.email “email@example.com“本地仓库—&gt;远程仓库的基本步骤git init 新建一个仓库git status 查看仓库当前的状态git add 可反复多次使用，添加多个文件；git add ./–all 添加当前文件夹的所有文件git commit -m “修改内容” 提交到本地仓库git remote 查看当前配置有哪些远程仓库git remote add origin https://github.com/WangHuagang/git-demo.git 将文件添加到指定的GitHub上的仓库git push -u origin master(分支) 将文件推送到远程仓库上git pull origin master(将远程仓库的东西“拉”回来)其余常用的命令git status -s 查看变更日志git log 可以查看提交日志git reset –hard (6位版本号) 回归到指定版本git diff 可以用于对比当前状态和版本库中状态的变化git branch 查看分支git branch （分支名） 创建一个新的分支git checkout （分支名） 切换分支git clone https://github.com/WangHuagang/git-demo.git .(.表示当前目录) 将远程仓库整个项目克隆到当前目录git merge 合并某分支到当前分支git branch -d 删除分支将本地文件放在github上显示1.创建gh-pages分支，利用gh-pages分支上传到远程仓库2.配置文件CNAME：绑定域名 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[夜神 Android studio连接配置第三方模拟器·夜神]]></title>
    <url>%2F2018%2F03%2F30%2FAndroid-studio%E8%BF%9E%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E6%8B%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Android Studio怎样连接配置第三方模拟器前言想必大家都体验了一把Android studio的环境搭建，总会出现莫名其妙的问题，刚刚搭建好，写好“Hello World”准备运行，折腾了半天，结果AS自带的模拟器运行不上，缺少一个加速软件。到这里，心已经凉了一大截了，好吧，换第三方模拟器，genymotion肯定是首选。到官网进行注册，然后下载下来，傻瓜式的安装好genymotion和virtualbox，眼看就要成功了，报错，纳尼！！！居然报错了！没错，他就是报错了。又捣鼓半天，放弃了，再找找其他的第三方模拟器吧，好吧，现在直接步入正题。 夜神模拟器夜神安卓模拟器，电脑玩手游的新一代神器。是当前唯一一款采用世界领先的内核技术（基于Android4.4.2 版本内核针在电脑上运行深度开发），具有同类模拟器中最快的运行速度 和最稳定的性能。玩家可以通过本软件在电脑上玩手机游戏， 感受更大的屏幕、更快的速度、更完美的操控体验。直接步入正题。 下载夜神模拟器 官网下载 傻瓜式安装好夜神。 运行夜神模拟器。 打开命令行窗口。 cd到夜神的安装目录（如cd D:\Program Files\NOX\Nox\bin）。 执行以下命令：nox_adb.exe connect 127.0.0.1:62001，连接上模拟器。 在Android studio中运行app，弹出的ADB中选择连接好的夜神就可以了。 若Android Studio连接不上夜神，重启连接模拟器即可链接上。 OK，现在你就可以愉快的敲你的代码了！有什么问题可以给我留言哦。 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数排序·JavaScript实现]]></title>
    <url>%2F2018%2F03%2F29%2F%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序算法计数排序计数排序就是遍历数组记录数组下的元素出现过多次，然后把这个元素找个位置先安置下来，简单点说就是以原数组每个元素的值作为新数组的下标，而对应小标的新数组元素的值作为出现的次数，相当于是通过下标进行排序。 算法原理计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。 时间复杂度它的复杂度为Ο(n+k)（其中k是整数的范围）。 代码实例1234567891011121314151617181920function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var k = 0; k &lt;len; k++) &#123; var length = C[k]; for(var m = 0 ;m &lt;length ; m++)&#123; B.push(k); &#125; &#125; return B; &#125; var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2]; console.log(countingSort(arr)); 计数排序动画演示 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>js算法</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序·JavaScript实现]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序算法插入排序插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据。 算法原理可以这么理解，在一个数组中我们不知道哪个是最小值，那么就假定第一个就是最小值，然后取第二个值与第一个值比较产排序后的序列，然后再取第三个值与排序后的序列进行比较插入到对应的位置，依次类推。 时间复杂度若数据的初始状态是正序的，那么只需要扫描一趟就完成了。此时是最好的时间复杂度：O(n)。若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。平均时间：O(n^2)。 代码实例1234567891011121314function insertionSort(array) &#123; for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while ( array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; return array; &#125; var arr=[2,5,3,6,1,7,9,4]; console.log(insertionSort(arr)); 插入排序动画演示]]></content>
      <categories>
        <category>js算法</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序·JavaScript实现]]></title>
    <url>%2F2018%2F03%2F27%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序算法快速排序通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法原理可以这么理解，在一个数组中我们不知道哪个是最小值，那么就假定第一个就是最小值，然后取第二个值与第一个值比较产排序后的序列，然后再取第三个值与排序后的序列进行比较插入到对应的位置，依次类推。 时间复杂度若数据的初始状态是正序的，那么只需要扫描一趟就完成了。此时是最好的时间复杂度：O(n)。若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。平均时间：O(n^2)。 代码实例123456789101112131415161718var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; console.log(pivot);//查看每一次的中间点 var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right)); &#125;; var arr=[2,5,3,6,1,7,9,4]; console.log(quickSort(arr)); 快速排序动画演示 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>js算法</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序·JavaScript实现]]></title>
    <url>%2F2018%2F03%2F26%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序算法选择排序选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 算法原理对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。 时间复杂度若数据的初始状态是正序的，那此时是最好的时间复杂度：O(n^2)。若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。平均时间：O(n^2)。 代码实例12345678910111213141516171819function xz(arr)&#123; var len=arr.length; var minIndex,temp; for(var i=0;i&lt;len-1;i++)&#123; minIndex=i; for(var j=i+1;j&lt;len;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123;//判断更小的数 minIndex=j; &#125; &#125; temp=arr[i]; arr[i]=arr[minIndex]; arr[minIndex]=temp; &#125; return arr;&#125;var arr=[2,5,3,6,1,7,9,4];console.log(xz(arr)) 选择排序动画演示 当数据量比较小时（1000左右），使用选择排序比冒泡排序更快。 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>js算法</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序·JavaScript实现]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序算法冒泡排序它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 算法原理比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度若数据的初始状态是正序的，那么只需要扫描一趟就完成了。此时是最好的时间复杂度：O(n)。若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。平均时间：O(n^2)。 代码实例1.最基础，也是最容易理解的一种做法。123456789101112131415function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;var arr=[2,5,3,6,1,7,9,4];console.log(bubbleSort(arr)); 2.更简单一点的，但不是那么容易理解的一种算法。12345678910111213141516function bubbleSort2(arr) &#123; var i = arr.length-1; //初始时,最后位置保持不变 while ( i&gt; 0) &#123; var pos= 0; //每趟开始时,无记录交换 for (var j= 0; j&lt; i; j++)&#123; if (arr[j]&gt; arr[j+1]) &#123; pos= j; //记录交换的位置 var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; &#125; i= pos; //为下一趟排序作准备 &#125; return arr;&#125;var arr=[2,5,3,6,1,7,9,4];console.log(bubbleSort2(arr)); 冒泡排序动画演示 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>js算法</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[What is closure？怎样理解闭包]]></title>
    <url>%2F2018%2F03%2F19%2Fclosure%2F</url>
    <content type="text"><![CDATA[1.前言闭包这个东西在JavaScript中是一个很强大的东西，但是在初学的阶段总是被其概念绕晕，搞不清楚到底什么是闭包，感觉很高深。作者在刚学的时候也有一点懵圈，多看几次就会有自己的理解。任何东西都没有唯一的标准，只要适合自己，自己能够理解的就是正确的。由于作者水平有限，将自己的一些见解拿出来，希望大家能够提出宝贵的意见。 2.作用域在正式讲闭包之前，我们来简单的说一说作用域这个东西。这个很有助于大家理解后面的闭包。什么是域？简单的说就是一个被圈起来的地方，也就是变量能够访问的一个范围。众所周知，变量的作用域分为全局变量和局部变量。定义在函数外部的称为全局变量，在函数内部的称为局部变量。这里顺带提一下，变量提升这个玩意儿，也就是和“先声明后使用差不多的道理”，后面我将会举一个例子来说明。举个例子，全局变量和局部变量:123456789101112var a='wang';function fun()&#123; var b='huagang'; console.log('这是在函数内部的输出'); console.log(a); console.log(b);&#125;fun();//调用函数console.log("这是在函数外部的输出");console.log(a);console.log(b); 运行结果:最后一个输出b的时候抛出了一个未定义异常，由此可见，全局变量（a）在函数内部和外部都是能访问的，但是局部变量不是这样的，在函数作用域外是不能访问到函数内部的变量（b）的。这里顺带讲一下【变量提升】吧，简单的举一个例子。1234var a;console.log(a);a='wang';console.log(a) 根据输出情况可以看出，第一次输出a并没有报异常，而是undefined。第二次便能输出a的值。这就是变量提升的特点，在变量还没赋值前就拿来使用了。 3.嵌套函数的作用域嵌套函数，顾名思义就是在函数的内部再写一个或多个函数。下面举一个例子来讲解一下嵌套函数的作用域。12345678910111213141516function funA(c)&#123; var a='wang'; function funB()&#123; var b='gang'; console.log("在函数B中的输出：") console.log(a); console.log(c); console.log(b); &#125; funB(); console.log("在函数A中的输出：") console.log(a); console.log(c); console.log(b);&#125;funA('hua');//调用函数A并传参 函数B就是嵌套在函数A中的嵌套函数，它可以继承函数A的变量和参数，但是B中的变量A是不能访问的，就好像B给自己的门上了锁，“只进不出”，我可以拿你的东西，但是你不可以拿我的东西。B这样就形成了一个自己独有的封闭空间，这就是一个闭包。从不同的角度来看：从语法结构上看，函数A包含函数B；从作用域来看，函数B包含函数A，也就是说B能访问的空间比A大。因此可以想象得出，假如B函数中还有一个嵌套函数X，那么这个X函数也是一个闭包，作用域包含B和A。这样下去就形成了一个作用域链。 4.闭包相信通过上面的讲解，大家已经懂得了什么是闭包，现在再讲讲一些关于闭包的特点或者特性吧。 保存变量什么是保存变量？加入B这个闭包需要两个变量才能运行，但是刚开始只传了一个参数进去，所以这时候闭包就会把这个变量的值进行保存，等待第二个变量传入，而不是丢弃这个变量的值。下面举一个例子进行说明吧。123456789function funA(a)&#123; function funB(b)&#123; return a + b; &#125; return funB;//调用函数B的引用&#125;var x = funA(2);var sum = x(3);console.log(sum);//输出结果 5 当函数A传进参数a=2时，这时闭包B就将a进行保存，等到再传b=3时再进行计算。这就是闭包的保存变量。 5.为什么要使用闭包使用闭包的最大的好处——避免变量的污染。也就是说你在闭包中声明的变量不会影响在其他地方也使用这个变量名称，因为闭包将这个变量锁在自己的门里面保护起来了，外部是无法修改的。1234567891011function funA()&#123; function funB(b)&#123; var a = 'wang';//内部变量 c return a+b ; &#125; return funB;&#125;var a = 'hua';//外部变量x，是不能改变闭包B中的变量a的var sum = funA()(a);console.log(a);console.log(sum); 可以看出，外部变量是不能修改闭包中的变量a的值的，从而保护了a的值，使其不会受到污染。 闭包的分享就讲到这里啦，我相信大家能够对闭包能够有一定的了解。当然，由于作者水平有限，这只是个人的见解，有误的地方还希望多多包涵，或者留言告知我。 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js如何实现倒计时的原理分析及实现]]></title>
    <url>%2F2018%2F03%2F18%2FcountDown%2F</url>
    <content type="text"><![CDATA[js倒计时原理倒计时=预计时间点-当前时间点最后将倒计时转换成我们所需要的格式即可（eg：时分*秒）再使用setInterval(function, 1000);每一秒执行一次，动态刷新一次就好。 js代码实现timer 1234567891011121314151617181920212223countDown();timer = setInterval(countDown, 1000);// 倒计时计算函数function countDown()&#123; var nowTime = new Date(); // 获取当前日期 var endTime = new Date(2018,4,20,20,35,0); //预计时间，注意month需要减1 var t = Math.floor((endTime - nowTime)/1000); // 计算差值（单位：秒） var Day = Math.floor(Math.floor(t/86400)); // 天（86400 = 24*3600） var Hour = Math.floor(t%86400/3600); // 时 var Min = Math.floor((t%3600)/60); // 分 var Sec = t%60; // 秒 if ( t==0 )&#123; clearInterval(timer); document.getElementById(&quot;showDiv&quot;).innerHTML = &quot;倒计时结束！&quot;; &#125; else &#123; document.getElementById(&quot;showDiv&quot;) = &quot;倒计时还有：&quot; + add(Day) + &quot;天&quot; + add(Hour) + &quot;:&quot; + add(Min) + &quot;:&quot; + add(Sec); &#125;&#125;function add(iNum)&#123; return iNum&lt;10 ? &quot;0&quot;+iNum : iNum; //若时间是个位数，则添加一个0在前面&#125; 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base64编码的原理及分析]]></title>
    <url>%2F2018%2F03%2F18%2Fbase64%2F</url>
    <content type="text"><![CDATA[1.为什么要使用base64编码因为有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，像ASCII码的控制字符就不能通过邮件传送。这样就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。最好的方法就是在不改变传统协议的情况下，开辟一种新的方案来支持二进制文件的传送。把不可见字符用可见字符来表示。而Base64就是一种基于64个可见字符来表示二进制数据的表示方法。 提示：不可见字符其实并不是不显示，只是这些字符在屏幕上显示不出来，比如：换行符、回车、退格等字符。 2.base64编码的原理Base64可以将ASCII字符串或者是二进制编码成只包含A—Z，a—z，0—9，+，/ 这64个字符（ 26个大写字母，26个小写字母，10个数字，1个+，一个 / 刚好64个字符）。 Base64的编码规则是将3个8位字节(3×8=24位)编码成4个6位的字节(4×6=24位)，之后在每个6位字节前面，补充两个0，形成4个8位字节的形式，那么取值范围就变成了0~63。又因为2的6次方等于64，所以每6个位组成一个单元。 下图为base64的字符转换表： 说太多了感觉复杂，直接上例子： 该图片转载自 https://www.jianshu.com/p/dd8bffc91c3d 所以，abc的base64的编码为YWJj；ab的base64编码为YWI=；a的base64编码为YQ==。 若末尾的为0，则对应的是A，但通常都用=来表示。因为 = 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 = 时即可知道一个Base64编码字符串结束。解码是对编码的逆向操作，但注意一点：对于最后的两个 = 字符，转换成两个A 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息。 在实际开发过程中，base64一般用于字符和图片的编码，最后，推荐一个在线base64的编码与解码网址：base64编码 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实战数据结构——列表/元组]]></title>
    <url>%2F2018%2F03%2F18%2FsingCount%2F</url>
    <content type="text"><![CDATA[Python实战题目比赛评分：校园歌手大奖赛中，每个歌手的得分由10名评委和观众决定，最终得分的规则是去掉10名评委所打分数的一个最高分和一个最低分，再加上所有观众评委分数后的平均值。请编写程序输入某个选手的10个评委分数和观众评分，计算其最后得分。 实战分析1.先接受用户输入的所有数据，存在列表中，此时的数据为字符串，应当转换成float，因为求平均分可能会出现小数。 2.利用Python的内置函数sort()进行排序，这里不用管是升序还是降序。 3.利用pop函数去掉第一个和最后一个数，即达到了去掉最高分和最低分的要求。 4.利用for in 遍历出剩下的所有数，并进行求和sum。 5.将sum与观众的分相加除以总人数便可算出最终得分。 Python代码123456789101112sum=0;inputScore=input("请输入10个分数，以,隔开:");aScore=input("请输入观众评分：")splitScore=inputScore.split(',');intScore = list(map(float, splitScore))# 把字符串转化成floatintScore.sort()intScore.pop();#去除末尾的数intScore.pop(0);#去除最开始的数for x in intScore: sum+=x;avg=(sum+float(aScore))/(len(intScore)+1);print("该选手最终得分：%.2f"%avg) 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9步教你搭建个人博客(Hexo+Github)]]></title>
    <url>%2F2018%2F03%2F17%2FhexoBlog%2F</url>
    <content type="text"><![CDATA[1.下载并安装node.js和npm（新版本的node已经自带npm，不用单独下载） 2.安装git的环境，傻瓜式的安装方法，默认安装即可 3.注册github账号，并创建一个新的仓库，仓库的格式一定要按照这种格式来：name.github.io，其他的默认就好 4.安装hexo，在电脑某个合适的地方新建一个文件夹（eg：blog），然后命令行进入到该文件夹，按照以下步骤进行安装-安装hexonpm install hexo -g-检查是否安装成功hexo -v-初始化该文件夹hexo init-安装所需要的组件hexo install-体验一下hexohexo g-开启服务器，正式访问网址体验hexo，输入localhost:4000访问hexo s若出现下图，启动服务器成功若不能成功，可能是端口冲突，请输入以下命令进行切换端口hexo server -p当看见出现以下页面，表示博客基本框架搭建成功 5.将hexo与GitHub联系起来，配置name和email（ps：如果已经配置过的可以忽略），在blog文件夹中右键打开Git Bash进行配置git config --global user.name &#39;your github name&#39;git config --global user.email &#39;your github email&#39; 5.1输入ssh-keygen -t rsa -C “cdu.whg@foxmail.com” ,连续按三个回车键，生成秘钥，得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。5.2 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent。5.3 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent。5.4 登陆GitHub，点击头像下拉菜单中的setting，添加ssh 5.5 新建一个new SSH Key ，输入名称和秘钥（id_rsa.pub文件中的秘钥）即可 6.配置，找到根文件夹下的_config.yml文件，按照下图进行修改配置 7.开启写博客之旅，输入一下命令，建立第一篇bloghexo new post &#39;blogName&#39; 在source/_posts目录下可看见增加了一个hello.md文件，编辑该文件内容，便可发布博客了 8.在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save9.安装完后便可以部署了，使用hexo d -g进行部署 部署成功后访问你的地址：http://用户名.github.io。那么就能看到生成发布的文章了。 OK，使用hexo+GitHub搭建基本的个人博客就完成了，后续会推出【提升版】，对个人博客进行更精致的设置以及绑定自己的域名。console.log(&quot;敬请关注!&quot;) 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用的基本命令]]></title>
    <url>%2F2018%2F03%2F17%2FgitLearn%2F</url>
    <content type="text"><![CDATA[配置git config –global user.name “Your Name”git config –global user.email “email@example.com“ 本地仓库—&gt;远程仓库的基本步骤git init 新建一个仓库git status 查看仓库当前的状态git add 可反复多次使用，添加多个文件；git add ./–all 添加当前文件夹的所有文件git commit -m “修改内容” 提交到本地仓库git remote 查看当前配置有哪些远程仓库git remote add origin https://github.com/WangHuagang/git-demo.git 将文件添加到指定的GitHub上的仓库git push -u origin master(分支) 将文件推送到远程仓库上git pull origin master(将远程仓库的东西“拉”回来) 其余常用的命令git status -s 查看变更日志git log 可以查看提交日志git reset –hard (6位版本号) 回归到指定版本git diff 可以用于对比当前状态和版本库中状态的变化git branch 查看分支git branch （分支名） 创建一个新的分支git checkout （分支名） 切换分支git clone https://github.com/WangHuagang/git-demo.git .(.表示当前目录) 将远程仓库整个项目克隆到当前目录git merge 合并某分支到当前分支git branch -d 删除分支 将本地文件放在github上显示1.创建gh-pages分支，利用gh-pages分支上传到远程仓库2.配置文件CNAME：绑定域名 git搭建自己的博客1.npm install hexo-cli -g 安装hexo2.hexo init blog 新建一个博客仓库3.cd blog 到博客文件夹下4.npm install 安装需要的包5.hexo serve 开启博客 hexo搭建博客更多的配置将会在后面继续更新 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
</search>
