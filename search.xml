<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序入门（一）之开发工具介绍]]></title>
    <url>%2F2018%2F06%2F16%2FweChat%2F</url>
    <content type="text"><![CDATA[什么是小程序英文名 mini program,一种崭新的应用程式。2016年张小龙（微信创始人）提出微信应用号，当时他的描述是，小程序是一种不需要下载安装即可使用的应用，他实现了应用触手可及的梦想，用户扫一扫或者搜一下即可打开应用，也体现了用完即走的理念，用户不用关心是否安装太多应用的问题，应用无处不在，随时可用，但又无序安装卸载。因为苹果公司告了所以改名微信小程序。2017年年初，给用户开放了入口。但是只能企业，后面对个人开放了。目前比较火爆的微信小程序，跳一跳之类的。官网：mp.weixin.qq.com 开发准备工作注册小程序账号，利用微信号注册即可，注册地址为：戳这儿 小程序开发者工具下载，下载地址为：戳这儿 开发工具介绍 开发者工具分为四个部分：模拟器，编辑器，调试器，工具栏 模拟器：当我们保存了编辑的代码，就可以直接在模拟器中看到效果 编辑器：小程序所有的开发代码都可以在这里修改。 调试器：继承了许多调试小程序需要的功能 工具栏：用于编译，预览小程序的源代码 项目搭建 1、选择在本地创建的项目目录 2、填写AppID 查找AppID，登录小程序官网官网：mp.weixin.qq.com-&gt;设置-&gt;开发设置-&gt;AppID 项目目录介绍 |–pages |--每个页面(index) //在pages文件夹中，每一个页面都是有个文件夹 index.js index.wxml index.wxss index.json |--utils app.js app.json app.wxss project.config.json //工程配置文件 描述整个项目的参数 1、pages:放所有页面的文件夹，此目录下的每一个文件夹代表一个页面，那咱们的项目两个页面就两个文件夹 2、每个页面包含四个文件 .wxml文件是界面文件， ----&gt;html .js是事件交互文件，用于处理界面的点击事件等功能； ---&gt;js .wxss为界面美化文件，让界面显示的更加美观； ---&gt;css .json为配置文件，用于修改导航栏显示样式等，小程序每个页面必须有.wxml和.js文件， 其他两种类型的文件可以不需要。 3、util：该文件件主要用于存放全局的一些.js文件，公共用到的一些事件处理代码文件可以放到该文件夹下， 用于全局调用。 4、app.js : 系统的方法处理文件，主要处理程序的声明周期的一些方法；例如：程序刚开始运行时事件处理等 5、app.json : 系统全局配置文件，设置导航头的颜色，字体大小，下面有没有tabbar等功能，具体页面的配置在页面的json文件中单独修改； 6、app.wxss : 全局的界面美化代码 7、project.config.json 通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置.考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 project.config.json， app.jsApp() 注册一个小程序，整个的app在整个小程序里面只会调用一次，整体是一个app，app下面有很多page，在这个app里面配置的东西，在每个页面都可以使用 onLaunch 函数类型 声明周期函数-监听小程序初始化，全局只会触发一次 globalData：全局的数据 app.jsonpages 接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的[路径+文件名]信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。 注：文件名不需要写文件后缀，因为框架会自动去寻找路径下 .json, .js, .wxml, .wxss四个文件进行整合。 如果添加后缀报错。 windows 小程序所有页面的顶部背景颜色，文字颜色定义在这里的 “backgroundTextStyle”:”light”, //下拉 loading 的样式，仅支持 dark/light “navigationBarBackgroundColor”: “#fff”, //导航栏背景颜色，如”#000000” 颜色值最好不要写单词，十六进制也不要简写 “navigationBarTitleText”: “WeChat”, //导航栏标题文字内容 “navigationBarTextStyle”:”black” //导航栏标题颜色，仅支持 black/white Page配置 “pages”:[ “pages/index/index”, “pages/center/center” ], 在tabBar里面进行设置的路由，将会固定在页面的底部。 头部配置 “window”:{ “backgroundTextStyle”:”light”, “navigationBarBackgroundColor”: “#fff”, “navigationBarTitleText”: “WeChat”, “navigationBarTextStyle”:”black” } 路由配置“tabBar”: { “list”: [ { “pagePath”: “pages/index/index”, “text”: “首页”, “iconPath”:”img/index.png”, //默认的图标 “selectedIconPath”:”img/linghtZB.png” //选中后的图标 }, { “pagePath”: “pages/center/center”, “text”: “个人中心”, “iconPath”: “img/center.png”, “selectedIconPath”: “img/center.png” } ] } 结束微信小程序的介绍以及小程序开发工具以及具体的配置信息都已经分享完了，了解了这些就可以开始小程序的开发啦。常用的标签及语法见下一期博客啦^_^ var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装 | Node连接MySQL并封装其增删查改]]></title>
    <url>%2F2018%2F05%2F17%2Fnode-mysql%2F</url>
    <content type="text"><![CDATA[Node连接Mysql说到node，可能大家会想到MOngoDB作为数据库，这里将会介绍node与mysql的连接，并分享了封装好的实例代码，在项目开发中可直接使用。下一篇博客将会讲node连接MongoDB。 安装Mysql模块1npm install mysql 连接Mysql1234567891011121314151617const mysql = require('mysql');let connection = mysql.createConnection(&#123; host : 'localhost', user : 'root', password : 'password', database : 'test'&#125;);connection.connect(function(err) &#123; if (err) &#123; console.error('连接失败: ' + err.stack); return; &#125; console.log('连接成功 id ' + connection.threadId);&#125;); host：连接的服务器user：数据库用户名password：设置的MySQL密码database： 要连接的数据库名 常用的SQL语句具体的使用这里不做详细说明，包括select、insert、update、delete等语句。 Node操作Mysql查询 123456connection.query('SELECT * FROM t_user WHERE username = "whg"', (err, results, fields) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 添加 123456connection.query('INSERT INTO t_user(username, pass) VALUES(?, ?)',['whg', '123'], (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 删除 123456connection.query('DELETE FROM t_user WHERE id = 1', (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 更新 123456connection.query('UPDATE t_user SET pass = "321" WHERE username = "whg"', (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 结束连接 1234connection.end(function(err) &#123; &#125;);connection.destroy(); 这两种都行，第二种是强制结束。 封装说了这么多，感觉操作起来还是挺简单的。在实际开发中，我们想要操作起来更方便，那就让我们自己封装一下来使用。直接上代码： 封装好的代码1.数据库配置文件12345678//配置链接数据库参数module.exports = &#123; host : 'localhost', port : 3306,//端口号 database : 'nodetest',//数据库名 user : 'root',//数据库用户名 password : '123456'//数据库密码&#125;; 2.封装、暴露方法12345678910111213141516171819202122232425262728293031323334let mysql = require('mysql');//引入mysql模块var databaseConfig = require('./mysql.config'); //引入数据库配置模块中的数据//向外暴露方法module.exports = &#123; query : function(sql,params,callback)&#123; //每次使用的时候需要创建链接，数据操作完成之后要关闭连接 var connection = mysql.createConnection(databaseConfig); connection.connect(function(err)&#123; if(err)&#123; console.log('数据库链接失败'); throw err; &#125; //开始数据操作 //传入三个参数，第一个参数sql语句，第二个参数sql语句中需要的数据，第三个参数回调函数 connection.query( sql, params, function(err,results,fields )&#123; if(err)&#123; console.log('数据操作失败'); throw err; &#125; //将查询出来的数据返回给回调函数 callback &amp;&amp; callback(results, fields); //results作为数据操作后的结果，fields作为数据库连接的一些字段 //停止链接数据库，必须再查询语句后，要不然一调用这个方法，就直接停止链接，数据操作就会失败 connection.end(function(err)&#123; if(err)&#123; console.log('关闭数据库连接失败！'); throw err; &#125; &#125;); &#125;); &#125;); &#125;&#125;; 3.演示实例123456789101112var db=require('../model/mysql.js');// 查询实例db.query('select * from t_user', [],function(result,fields)&#123; console.log('查询结果：'); console.log(result);&#125;);//添加实例var addSql = 'INSERT INTO websites(username,password) VALUES(?,?)';var addSqlParams =['咕噜先森', '666'];db.query(addSql,addSqlParams,function(result,fields)&#123; console.log('添加成功')&#125;) 结束想要使用的朋友，可以直接把封装好的两个文件copy到项目中，改一下配置就可以使用了，大大提高开发效率。下一篇将会分享Node连接MongoDB。 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【零开始】怎样购买、配置服务器及发布网站（页）？]]></title>
    <url>%2F2018%2F05%2F15%2FwebService%2F</url>
    <content type="text"><![CDATA[本文主要讲解从零开始搭建属于自己的服务器，购买==&gt;配置==&gt;发布，这么一系列详细流程，让自己做的网页能够发布到网络上，一起来开启服务器之旅！本文主要以腾讯云学生套餐进行讲解，其他的云服务器操作类似。若对你有帮助的话，希望能够坚持做下去。 本文原创首发：咕噜先森的博客 购买服务器服务器目前使用得最多的是阿里云和腾讯云，用起比较稳定。这里讲解的是腾讯云，其实很多浏览器的配置和使用都差不多。这里演示的是腾讯云的学生套餐，作为学生狗，在校期间用用免费的就行。进入腾讯云云+校园服务计划，选择【体验版】(PS:每日零点开始抢，每天100个名额，限额抢购，抢！抢！)套餐，10元/月。 选择配置腾讯云免费学生套餐 【1核2G，1M带宽 50G云硬盘】，这是腾讯云学生套餐默认的配置，不能进行选择。接下来选择服务器其他的配置选项： 地域：即服务器的位置。选择离访问者比较近的服务器的区域就行，越近的话访问的速度相对会快一点。【例如：成都】 可用区：根据地域进行选择就行，问题不大。【例如：成都一区】 操作系统：有Linux、Windows等系统，Linux又包括不同的版本：CentOS、Debian、Ubuntu等。选择一个自己熟悉的系统就行。【例如：Windows Server】 系统版本：根据你选择的操作系统进行选择适合自己的版本。【例如：Windows Server 2012 R2 标准版 64位中文版】 购买时长：选择一个月，因为腾讯云的学生套餐的优惠券是每个月进行领取，所以只能一个月一个月进行购买。 对象存储：使用默认的50G就好。 域名服务：第一年免费使用.cn域名。若自己有域名，可以选择【否】，若没有可以选择【是】，然后输入一个自己想要的域名，但是这个域名必须是全球唯一的，所以可能你想要的域名已经被注册了，那么你就只能注册其他的域名了。 核对信息核对信息，查看自己的购买的配置是否是自己需要的配置。支付完订单，那么你的服务器就已经到手了，就可以开始撸自己的服务器了。 查看服务器那么如何查看自己已经买好的服务器呢。登录腾讯云，进入控制台管理，点击导航栏【云产品】==&gt;【云服务器】==&gt;【云主机】，便能查看自己的云主机啦。此处可以查看云主机的各种状态以及一些操作，其中可以查看自己的公网IP和内网IP。 服务器备案与域名解析严格意义上来讲域名备案的目的就是为了防止在网上从事非法的网站经营活动，打击不良互联网信息的传播，如果网站不备案的话，7天后将会关停服务器，导致不能正常使用。目前国内的所有服务器都需要进行备案。在这里，直接引用腾讯云给出的备案官方文档，很详细，参照着备案就行，从开始备案到完成的时间可能在20天左右。域名解析即将域名与IP绑定起来，通过DNS解析，便能通过域名访问IP对应的网站。详细的域名解析见这篇博客PS：《服务器备案与域名解析》这一步可以先跳过，把后面的步骤全部搞通了再来处理这一模块也是可以的。 登录云主机登录云主机便可以操作整个云服务，并配置成你想要的样子。点击【登录】便可查看如何进行登录，根据不同的系统选择不同的登录方式。登录步骤（Windows）： 快捷键【win+R】，输入“mstsc”命令，打开远程桌面对话框。 输入框输入云主机的公网IP地址，点击连接。 输入默认的用户名【Administrator】，同时输入自己购买服务器时设置的密码，点击确定便能连接到远程桌面。 注意：连接时记得在网速好的时候，否则可能带不动导致连接不上。进入云主机过后，大家会发现和我们平时使用的Windows没什么区别，操作起来就简单多了。 开启服务器好了，到了这一步离成功已经很近了。怎样才能让我们的服务器跑起来，能够运行我们自己写的网页或者网站。那么你需要准备下面这个软件——PHPStudy，其实开启服务器的很多，比如Tomcat，只是这里是使用PHPStudy进行演示。PHPStudy下载地址，下载后进行傻瓜式的安装即可。安装好后，正常启动服务器的效果如下图所示(即前面是绿色小圆点而不是红色小圆点)。这里我们只需要管Apache即可，不用管Mysql，当然若你的项目需要数据库，那么肯定是需要进行相关配置的。Apache默认端口为80，若不使用80端口的话，那么在使用ip地址或者域名访问的时候需要在其后添加端口号。MySQL默认端口为3306。若不能正常启动，说明端口被占用，这是需要终止其他占用该端口的进程即可。启动过后，需要简单的配置一下端口及目录。操作步骤：点击【其他选项菜单】==&gt;【打开配置文件】==&gt;【vhosts-conf】此时打开应该是空的，只需要把下面的配置添加进去即可。 12345678910&lt;VirtualHost _default_:80&gt;DocumentRoot "C:\phpstudy\WWW" &lt;Directory "C:\phpstudy\WWW"&gt; Options +Indexes +FollowSymLinks +ExecCGI AllowOverride All Order allow,deny Allow from all Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; PS：记得修改自己的根目录的位置。那么我的网页应该放在哪个文件夹下才能被访问呢？这时需要打开网站的根目录。打开根目录的步骤:点击【其他选项菜单】==&gt;点击【网站根目录】，如下图所示：打开后的文件夹便是网站的根目录，这时文件夹中有一些文件是PHPAdmin的一些文件，这时在浏览器地址栏中输入localhost或者127.0.0.1便能访问到PHPAdmin的主页，到此说明phpstudy能够正常开启服务了。以后上传的网页就需要上传到这个文件夹下，就能正常访问了。若在当前目录有index.html，那么直接访问ip地址或者域名，打开的网页便是默认的index.html。如想访问非默认缺省主页，需要在ip或域名后添加该文件的相对路径。 【例如】在WWW下有一个文件夹aaa中有一个文件aaa.html,那么这时候需要在浏览器地址栏中输入ip地址/aaa/aaa.html（119.149.78.109/aaa/aaa.html）配置好后，你的服务器便跑起来了，你便能访问你配置好的目录下的网页了，同时也可以使用ip地址进行访问。 这里只做了简单的开启服务器的功能，更多详细的关于phpstudy的使用可参考官网给出的一篇文章 如何上传文件到服务器所有的环境都搭好了，那么应当怎样将我们自己做好的网页放在服务器上呢？这里讲解三种方法供读者参考，读者可选择适合自己的方法。 方法一想必大家都使用过ftp进行上传文件，对，这里就是需用ftp进行上传文件。那么上传之前你需要做一个准备工作，那就是在云服务器上配置ftp。这里需要在云主机上安装一个软件【FileZilla Server】，官网下载地址。安装方式也是和phpstudy一致，傻瓜式安装即可。安装好后，打开软件点击【File】启动FileZilla Server。 设置ftp账号点击【Edit】==&gt;【Users】点击【Add】按钮进行添加账户，同时填写账户的名称【例如：test】 设置密码在【Password】选项前打勾，并输入密码即可。 选择共享的文件夹如下图所示，点击【1】==&gt;点击【Add】选择想要共享的文件夹，这里可直接选择phpstudy的根目录，这样上传的文件夹可直接访问。图中第3步便是设置这个添加的账户对当前目录的文件和文件夹的权限，有增、删、改、查，可根据需求进行设置，若是自己使用可全部勾选上。后面两项可以不用设置，直接使用默认的即可。 到此为止，云服务器上的ftp已经配置完成，现在可直接在本机电脑上通过ftp软件或者资源管理器使用刚刚设置好的用户和密码进行登录，然后便能上传文件了。例如使用【资源管理器】进行登录上传。打开【我的电脑】，在地址栏中输入：【ftp:IP地址】，这时会弹出一个登录框，要求输入账号和密码，输入刚刚添加的账号和密码即可。这时便登录进来了，直接把要上传的文件拖进来或者复制进来就能完成上传了。例如上传一个hello.html文件到服务器，直接把hello.html拖拽进去或者复制进去就OK了。下图是为上传hello.html之前的情况：下图是为上传完成hello.html的情况：这时，我们在云服务器上打开对应的那个目录，便能查看到刚刚那个hello.html文件了。这时我们在浏览器地址栏中输入IP地址+hello.html便能访问到hello.html文件中的内容了。这种方法是使用得比较多的，当然使用ftp软件是一样的，只要配置好后使用起来还是很简单的。 方法二登录进入云服务器过后，直接通过复制粘贴进行上传文件。但是有一个弊端是，若文件过大很容易造成上传失败。 方法三在云服务器中直接绑定本机电脑上的某一个磁盘，这样就可以将本机的文件绑定在云服务器上，再通过复制粘贴便能轻松完成文件的上传。 结语通过这些详细的步骤，我相信你已经从零搭建起自己的服务器了，享受了这么一个过程。过程很重要，当然结果做出来了还是很有成就感的。当然，由于作者一个人经历、水平也有限，本文中肯定有一些错误，很希望大家提出意见与建议，可以在文末进行留言，作者将会进一步进行改进。码字也不容易啦，如果你觉得本文对自己有帮助，可以在博客文章下面打赏一点棒棒糖零花钱，多少随意啦^_*_^ var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法详解】冒泡/选择/插入/快速排序详解·JS实现]]></title>
    <url>%2F2018%2F04%2F19%2Fsort%2F</url>
    <content type="text"><![CDATA[最近再深入了解了一下排序算法，大概总结了一下，直接在代码中一行一行的进行注释。算法思路==&gt;实现代码==&gt;代码详细注释==&gt;演示过程，带来更加直观的理解。所有的代码可直接运行，查看结果。 冒泡排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;冒泡排序&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //swap是交换数组内位置的函数 function swap(_arr, index1, index2) &#123; const arr = _arr; arr[index1] += arr[index2]; arr[index2] = arr[index1] - arr[index2]; arr[index1] -= arr[index2]; &#125; // 基本思路： // 前一项(i)与后一项(i+1)项比较，如果前一项比后一项大就交换这两项； // 重复这个过程到最后； // 一趟完成后再从头开始重复上面的步骤，有多少项就要重复几次。 function bubbleSort(_arr) &#123; const arr = [].slice.call(_arr); const len = arr.length; for (let i = 0; i &lt; len; i += 1) &#123; for (let f = 0; f &lt; len - 1; f += 1) &#123; // 相邻两个元素进行比较 if (arr[f] &gt; arr[f + 1]) &#123; // 交换位置 swap(arr, f, f + 1); &#125; &#125; &#125; return arr; &#125; console.log(bubbleSort([2, 5, 4, 7, 3])) // 演示过程 // // 初始 // 5 4 9 5 3 // // 第一趟 // 4 5 9 5 3 // 5&gt;4，交换 // ^ ^ // 4 5 9 5 3 // 5&lt;9，不变 // ^ ^ // 4 5 5 9 3 // 9&gt;5，交换 // ^ ^ // 4 5 5 3 9 // 9&gt;3，交换 // ^ ^ // // 第二趟 // 4 5 5 3 9 // 4&lt;5，不变 // ^ ^ // 4 5 5 3 9 // 5=5，不变 // ^ ^ // 4 5 3 5 9 // 5&gt;3，交换 // ^ ^ // 4 5 3 5 9 // 5&lt;9，不变 // ^ ^ // // 第三趟 // 4 5 3 5 9 // 4&lt;5，不变 // ^ ^ // 4 3 5 5 9 // 5&gt;3，交换 // ^ ^ // 4 3 5 5 9 // 5=5，不变 // ^ ^ // 4 3 5 5 9 // 5&lt;9，不变 // ^ ^ // // 第四趟 // 3 4 5 5 9 // 4&gt;3，交换 // ^ ^ // 3 4 5 5 9 // 4&lt;5，不变 // ^ ^ // 3 4 5 5 9 // 5=5，不变 // ^ ^ // 3 4 5 5 9 // 5&lt;9，不变 // ^ ^ // // 第五趟 // 3 4 5 5 9 // 3&lt;4，不变 // ^ ^ // 3 4 5 5 9 // 4&lt;5，不变 // ^ ^ // 3 4 5 5 9 // 5=5，不变 // ^ ^ // 3 4 5 5 9 // 5&lt;9，不变 // ^ ^ // // 结果 // 3 4 5 5 9 // 改进方案 // 通过上面的排序过程，可以发现其实每一趟就可以确定最后一位的位置了， // 所以可以不用再比较最后的位置。代码改造也很小，只要在内循环减去已经确定的位置数即可。 function modifiedBubbleSort(_arr) &#123; const arr = [].slice.call(_arr); const len = arr.length; for (let i = 0; i &lt; len; i += 1) &#123; // 每一趟便能确定最后一个数，所以可以减少一些不必要的比较 for (let f = 0; f &lt; len - i - 1; f += 1) &#123; if (arr[f] &gt; arr[f + 1]) &#123; swap(arr, f, f + 1); &#125; &#125; &#125; return arr; &#125; console.log(modifiedBubbleSort([2, 5, 4, 7, 3])) // 演示过程 // 5 4 9 5 3 // // 第一趟 // 4 5 9 5 3 // 5&gt;4，交换 // ^ ^ // 4 5 9 5 3 // 5&lt;9，不变 // ^ ^ // 4 5 5 9 3 // 9&gt;5，交换 // ^ ^ // 4 5 5 3 9 // 9&gt;3，交换 // ^ ^ // // 第二趟 // 4 5 5 3 9 // 4&lt;5，不变 // ^ ^ // 4 5 5 3 9 // 5=5，不变 // ^ ^ // 4 5 3 5 9 // 5&gt;3，交换 // ^ ^ // // 第三趟 // 4 5 3 5 9 // 4&lt;5，不变 // ^ ^ // 4 3 5 5 9 // 5&gt;3，交换 // ^ ^ // // 第四趟 // 3 4 5 5 9 // 4&gt;3，交换 // ^ ^ // // 结果 // 3 4 5 5 9 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 插入排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;插入排序&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //swap是交换数组内位置的函数 function swap(_arr, index1, index2) &#123; const arr = _arr; arr[index1] += arr[index2]; arr[index2] = arr[index1] - arr[index2]; &#125; // 插入排序就是要把后面的数往前面插入。假定第一项已经排序了，接着从第二项开始，依次判断当前项应该插入到前面的哪个位置。 // 基本思路： // 1.从第二项开始(i=1)，当前项(i)，缓存其值和位置； // 2.向前遍历，指针f初始化为i位置，如果f-1大于当前项的值，则交换f和f-1（即f-1向后移动一位），并f--； // 3.如果遇到f-1小于当前值，或f=0时停止循环，这时候f即是当前项的位置，将之前的缓存值写入该位置。 function insertionSort(_arr) &#123; const arr = [].slice.call(_arr); const len = arr.length; // 从第2个元素开始和前面的元素比较，取到最后一个元素完 for (let i = 1; i &lt; len; i += 1) &#123; let f = i; // 获取到当前要比较元素的值 const temp = arr[i]; // 遇到f-1小于当前值，或f=0时停止循环 while (f &gt; 0 &amp;&amp; arr[f - 1] &gt; temp) &#123; // 值更大的那一个元素向后移动,即当前比较的元素向前插入 arr[f] = arr[f - 1]; f -= 1; &#125; // 这时候f即是当前项的位置，将之前的缓存值写入该位置 arr[f] = temp; &#125; return arr; &#125; console.log(insertionSort([2, 5, 4, 7, 3])) // // 演示过程 // 5 4 9 5 3 // // 第一趟，当前项是1号位，数字4 // _ 5 9 5 3 // 4&lt;5，5向后移动 // ^ ^ // 4 5 9 5 3 // 遍历结束，写入4 // ^ // // 第二趟，当前项是2号位，数字9 // 4 5 9 5 3 // 9&gt;5，不变 // ^ // 4 5 9 5 3 // 9&gt;4，不变，遍历结束 // ^ // // 第三趟，当前项是3号位，数字5 // 4 5 _ 9 3 // 5&lt;9，9向后移动 // ^ ^ // 4 5 _ 9 3 // 5=5，不变 // ^ // 4 5 _ 9 3 // 5&gt;4，不变 // ^ // 4 5 5 9 3 // 遍历结束，写入5 // ^ // // 第四趟，当前项是4号位，数字3 // 4 5 5 _ 9 // 3&lt;9，9向后移动 // ^ ^ // 4 5 _ 5 9 // 3&lt;5，5向后移动 // ^ ^ // 4 _ 5 5 9 // 3&lt;5，5向后移动 // ^ ^ // _ 4 5 5 9 // 3&lt;4，4向后移动 // ^ ^ // 3 4 5 5 9 // 遍历结束，写入3 // ^ // // 结果 // 3 4 5 5 9 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 选择排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;选择排序&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //swap是交换数组内位置的函数 function swap(_arr, index1, index2) &#123; const arr = _arr; arr[index1] += arr[index2]; arr[index2] = arr[index1] - arr[index2]; arr[index1] -= arr[index2]; &#125; // 选择排序算法是一种原址比较排序算法。这也是比较简单的过程，只要不断遍历找到最小的数依次放入位置即可。 // 基本思路： // 1.设定一个指针指向最小的数，从0号位开始； // 2.遍历数据，如果遇到比当前指针指向的数还小的数，就将指针重新指向这个新位置； // 3.遍历完成即得到了最小的数的位置，把0号位与这个位置的数交换； // 4.接下来就是1号位，重复以上步骤直到全部位置都正确 function selectionSort(_arr) &#123; const arr = [].slice.call(_arr); const len = arr.length; // 从0号位开始遍历，只取到倒数第二个值 for (let i = 0; i &lt; len - 1; i += 1) &#123; // 选定指针的位置，依次作为指针的指向 let indexMin = i; // 从第二个元素开始进行比较,取到最后一个元素 for (let f = i + 1; f &lt; len; f += 1) &#123; // 如果当前的元素比指针位的元素小，则把小的那个值赋值给indexMin if (arr[indexMin] &gt; arr[f]) &#123; indexMin = f; &#125; &#125; // 如果指针的位置换了位置，即不等于原始i的值，则交换位置 if (indexMin !== i) &#123; swap(arr, indexMin, i); &#125; &#125; return arr; &#125; console.log(selectionSort([2, 5, 4, 7, 3])) // 实例过程 // 5 4 9 5 3 // // 第一趟，指针指向0号位 // 5 4 9 5 3 // 4&lt;5，指针指向1号位 // ^ // 5 4 9 5 3 // 9&gt;4，指针不变 // ^ // 5 4 9 5 3 // 5&gt;4，指针不变 // ^ // 5 4 9 5 3 // 3&lt;4，指针指向4号位 // ^ // 3 4 9 5 5 // 遍历结束，交换0号位和4号位 // // 第二趟，指针指向1号位 // 3 4 9 5 5 // 9&gt;4，指针不变 // ^ // 3 4 9 5 5 // 5&gt;4，指针不变 // ^ // 3 4 9 5 5 // 5&gt;4，指针不变 // ^ // 3 4 9 5 5 // 遍历结束，1号位不变 // // 第三趟，指针指向2号位 // 3 4 9 5 5 // 5&lt;9，指针指向3号位 // ^ // 3 4 9 5 5 // 5=5，指针不变 // ^ // 3 4 5 9 5 // 遍历结束，交换2号位和3号位 // // 第四趟，指针指向3号位 // 3 4 5 9 5 // 5&lt;9，指针指向4号位 // ^ // 3 4 5 5 9 // 遍历结束，交换3号位和4号位 // // 结果 // 3 4 5 5 9 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;快速排序&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 快速排序的思想跟归并很像，都是分治方法，但它没有像归并排序那样将它们分割开，而是使用指针游标来标记，每次会确定一个参考数的位置。稍微会比前面的复杂一些。 // 基本思路： // 1.取数组的第0项作为参考数，缓存0号位的数。 // 2.设定一个从0号位开始的low指针，一个从末尾开始的high指针； // 3.先从high指针开始移动，指针指向的数与参考数做比较，如果大于或等于参考数则继续向前移动，如果小于参考数则停下并把high指针指向的数替换到当前low指针指向的位置； // 4.再从low指针开始移动，指针指向的数与参考数做比较，如果小于或等于参考数则继续向后移动，如果大于参考数则停下并把low指针指向的数替换到当前high指针指向的位置； // 5.如此循环交替移动两个指针，直到low指针的指向位高于或等于high的指向位； // 6.至此low指向位即是参考数的位置pivotloc，将参考数写入low指向的位置； // 7.以此位置pivotloc为分割，在左右两边重复上述的步骤，直到排序完成。 function quickSort(_arr) &#123; const arr = [].slice.call(_arr); function partition(low, high) &#123; // 首先设置一个参考的数，一般是以第一个数为参考数 const pivotkey = arr[low]; // 定义最左边的指针和定义最右边的指针 let i = low; let j = high; // 当i和j还没相遇的时候就一直循环 while (i &lt; j) &#123; // i&lt;j且数都比参考数大的时候从右往左找，找到比参考数pivotkey小的数 while (i &lt; j &amp;&amp; arr[j] &gt;= pivotkey) &#123; j -= 1; &#125; // 找到了比参考数小的数就停止下来，然后就该从左边开始找了 arr[i] = arr[j]; // // i&lt;j且数都比参考数小的时候从左往右找，找到比参考数pivotkey大的数 while (i &lt; j &amp;&amp; arr[i] &lt;= pivotkey) &#123; i += 1; &#125; // 找到了比参考数大的数就与右边找到的比参考数小的那个数进行交换位置，然后第一轮交换就结束了。然后继续又右边开始找，开始第二轮交换。 arr[j] = arr[i]; &#125; // 当i和j相遇的时候，这一次的所有交换就结束了。这时，将当前相遇的位置与参考数交换。 // 这时，参考数的左边都是比参考数小的数，右边都是比参考数大的数 arr[i] = pivotkey; return i; &#125; (function QSort(low, high) &#123; // 这时对两边的序列继续进行上面的操作，继续交换，进行排序， if (low &lt; high) &#123; const pivotloc = partition(low, high); // 左边的序列 QSort(low, pivotloc - 1); // 右边的序列 QSort(pivotloc + 1, high); &#125; &#125;(0, arr.length - 1)); return arr; &#125; console.log(quickSort([2, 5, 4, 7, 3])) // 演示过程 // 5 4 9 5 3 // // 第一趟，参考数为5 // 5 4 9 5 3 // high开始移动，3&lt;5，high停止 // ^L ^H // 3 4 9 5 3 // 将high指向数3写入到low位置 // ^L ^H // 3 4 9 5 3 // low开始移动，3&lt;5，继续前进 // ^L ^H // 3 4 9 5 3 // 4&lt;5，继续前进 // ^L ^H // 3 4 9 5 3 // 9&gt;5，low停止 // ^L ^H // 3 4 9 5 9 // 将low指向数9写入到high位置 // ^L ^H // 3 4 9 5 9 // high开始移动，9&gt;5，继续后退 // ^L ^H // 3 4 9 5 9 // high开始移动，5=5，继续后退 // ^L^H // 3 4 5 5 9 // 两指针重合，结束，确定参考数5的位置，写入 // * // // 第二趟，参考数为3 // 3 4 5 5 9 // high开始移动，4&gt;3，继续后退 // ^L^H* // 3 4 5 5 9 // 两指针重合，结束，确定参考数3的位置，写入 // * * // // 第三趟，参考数为4 // 3 4 5 5 9 // 两指针重合，结束，确定参考数4的位置，写入 // * * * // // 第四趟，参考数为5 // 3 4 5 5 9 // high开始移动，9&gt;5，继续后退 // * * * ^L^H // 3 4 5 5 9 // 两指针重合，结束，确定参考数5的位置，写入 // * * * * // // 第五趟，参考数为9 // 3 4 5 5 9 // 两指针重合，结束，确定参考数9的位置，写入 // * * * * * // // 结果 // 3 4 5 5 9 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经 | 腾讯春季校招前端实习生面试经历 | 感觉凉了]]></title>
    <url>%2F2018%2F04%2F11%2FTencentView%2F</url>
    <content type="text"><![CDATA[前言很久没有更博客了，因为最近太忙了，事情太多就没怎么写了。如果有相关的问题可在下面评论区留言，很乐意为你解答。 4月5日参加的腾讯的前端实习生的笔试，当时因为其他的事情，导致准备不充分，做得不是很好，所以做完笔试感觉已经凉了。加之后面学院科创室办比赛的事情以及个人评选十佳优秀团员的事情，就忙得已经淡淡忘了这件事了，也就没有去准备面试了。 4月10日，这两天一直在忙着整理十佳团员的资料，写个人简介，个人事迹，做宣讲PPT等，今天下午约好了学院新闻中心得帮我拍30秒的宣讲视频。所以一下午都在准备拍视频以及拍视频。下午4点过拍完了，回到工作室继续准备材料，做PPT，突然收到一封邮件，来自于腾讯校招。打开一看，自己都惊了，叫我第二天就去成都某酒店面试。一阵窃喜，但也很忧伤，这么久一直都没有准备面试，没有准备好。现在就很纠结明天到底去不去了，经过朋友、同学、家人的鼓励下，还是选择了去参加面试，就当去体验一次真正的面试（PS：之前从来没有参加过公司面试，腾讯是我第一次面试的公司）。好吧，放下手里的一切事情吧。在食堂吃了晚饭，就开始刷题复习了。 刷了两三个小时，晚上回寝室了，再看了一会儿，本来想多看一会儿，因为学校11点半会停电，然后就洗了个澡就上床睡觉了。但是在睡觉之前，做了一件事，那就是设了一个闹钟，7点钟，明天早上早点起来刷题吧。 第二天来到工作室，还没有两个人呢，就开始刷题吧，网上找的一些前端面试题和一些面经。想了想，可能看不完了，去找班主任请个假吧，下午一二节课就不去上课了，好好刷题吧（PS：上午三四节课在教室里面用手机刷，发现好像效果不大。）下午一二节同学都去上课了，我就留在工作室刷题，越刷越紧张，因为重来没有参加过公司面试。好吧，下午4点钟，坐地铁出发吧，去面试的酒店。原计划在地铁上再刷题，但是发现越到面试越浪。就像小时候一样，小考小耍，大考大耍。哎，在地铁上一个题也没看，就拿着自己的彩印的简历，刷刷新闻吧。一个小时左右，到了某酒店。到了指定的位置，发现早早就有人到了面试了，我打开邮件再看，写的是 请带好简历于4月11日18:00前往某酒店参加面试，我一直以为是18：00开始面试，原来这一整天都在面试。用微信扫完码签到完成，就慢慢等着面试吧。等了接近一个小时，广播和手机短信和微信终于通知我到某个房间去面试了。 正式开始第一次参加面试，还是大厂面试，虽然感觉已经凉了。全程大概40分钟左右，在一个五星级酒店的一个房间里，一对一的面试，面试官看起来还不错。一进去面试官问我大学在哪个位置？然后就他到他们招的是腾讯云服务的前端开发，刚好我大一的时候到现在一直在用腾讯云服务器。之后看了一下我的简历，算是正式开始了吧。 自我介绍，大概讲了一下自己的经历以及做过的项目和编写的书。（大一到现在的经历，大概用了7、8分钟） 你从做过的事（学长课堂：老生带新生）中最大的收获是什么？（分享中学习，学习中分享） 说了自己的项目，采用前后端分离做的，为什么逻辑业务都在前端做？（因为更熟悉js，虽然Node也是用js写） 如何解决跨域问题？（自己用过的是jsonp，其他的不是很了解） 对http有什么了解？（说了说常见的状态码和TCP的三次握手，以及和UDP的区别） vue为什么要使用虚拟DOM？（想必js操作DOMM更能够优化性能，减少资源的请求） 为什么js操作DOM更消耗资源呢？（只是了解过） 有没有看过vue的源码？（没怎么了解过） 做一道题：判断栈是在哪个容器？（很懵，没看懂题，琢磨了几分钟，面试官提示了pop和push，原来是考栈的先进后出嘛，但是代码没写出来，估计到这里已经凉了） 说说你这个【搜购】项目具体是怎样的以及主要用了哪些技术？（大体介绍了这个项目，以及自己想完善这个项目的想法） 顺便说到了另一个【商品收银系统】，讲了一下自己做的时候的难点？（这个问题就是下面一个问题） 说了一下echarts，以及返回数据显示的坑。（同步与异步造成的问题） 最后问了一下，你们写的这本书是在校内使用还是要出版发行？（说了一下要出版） 最后，你有什么问题想问我吗？（以下两个问题） 1.现在主要学哪一个技术栈好一点？（自己学的是vue，面试官说是根据具体的使用场景进行使用） 2.对于新出来的东西，是在刚出来的时候就接触，还是在等它成熟了再去使用？（给面试官提了一下刚出来的【快应用】，结果他不知道这个东西。他举例说了一下react native刚出来也不稳定，但是又能够适用的地方，还是会去使用它。） OK，面试官：感谢你的时间（顿时心里感觉又凉凉了），收拾简历准备走了，然后叫我把简历留下，不要带走，然后我就直接走了。 感受面试官问项目比较多，注重基础与底层，不要只是会运用，还要知道为什么它能够这样使用，多看看框架的源码。第一次参加面试，还是大厂面试，虽然感觉已经凉了，但是还是一次很不错的体验与经历吧，为自己后面的秋招攒人品吧。 如果有相关的问题可在下面评论区留言，很乐意为你解答。 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快运用 | 入门体验小教程 | 快到飞起]]></title>
    <url>%2F2018%2F04%2F04%2FquickApp%2F</url>
    <content type="text"><![CDATA[什么是快运用 快应用是基于手机硬件平台的新型应用形态，标准是由主流手机厂商组成的快应用联盟联合制定。 快应用标准的诞生将在研发接口、能力接入、开发者服务等层面建设标准平台，以平台化的生态模式对个人开发者和企业开发者全品类开放。 快应用具备传统APP完整的应用体验，无需安装、即点即用。 详情可见快运用官网官网 前言2018年3月20日，小米、中兴、华为、金立、联想、魅族、努比亚、OPPO、vivo、一加，共十家手机厂商在北京联合召开快应用标准启动发布会，手机厂商与中国信息通信研究院、电信终端产业协会、中国软件行业协会及数百家知名移动互联网应用企业共襄盛举，共同见证移动应用新生态的到来。 感觉看起来很牛逼，小编也想去看看究竟是个什么玩意儿。通过小编到官网的一探究竟，发现和Vue.js很相似，不管是结构还是语法上都很类似。好吧，话不多少，随着小编一起去体验一把吧。 准备工作 这里的入门教程 一台安卓手机或者是模拟器 一台电脑 出发1.搭建环境【安装node.js】需安装6.0以上版本的NodeJS，请从NodeJS官网下载，推荐v6.11.3注意: 不要使用8.0.*版本．这个版本内部ZipStream实现与node-archive包不兼容，会引起报错这是官方推荐的版本 【安装工具hap-toolkit】通过npm仓库安装，在命令行中执行以下命令：npm install -g hap-toolkit在命令行中执行hap -V会输出版本信息表示hap-toolkit安装成功，注意V是大写。 【创建工程】新建一个文件夹，打开命令行，并cd到新建的文件夹目录下，进行初始化项目，执行以下命令：hap init YourProjectName【安装依赖】一定要cd到你初始化的项目目录下，不是当前目录哦npm install【编译项目】在项目文件夹下，执行以下命令：npm run build这是，可能会报如下的错 淡定，只需要执行一次 hap update –force 即可解决, 对包强制进行升级。 然后再执行npm run build进行编译便能成功，可以看到如下界面。 编译成功以后，工程项目会多处两个文件夹： build：存放编译后的页面js文件和素材 dist：存放编译打包生成的rpk压缩文件，这个rpk就是快应用的最终执行文件了。 【最后一步，预览项目】你的手机或者模拟器需要安装 快应用调试器 和 平台预览版 下载后用直接USB或者QQ传输安装到手机。注意，两个apk都要安装！平台预览版是模拟快应用的运行时环境的。 安装前面编译出来的rpk文件 方法一： 本地安装预览 将你的工程中/dist目录下编译产出的rpk文件，复制到手机文件系统中。打开手机上的“快应用调试器” 点击“本地安装” 选择手机文件系统前面复制进来的rpk文件，即可预览到你的快应用的界面。 方法二： 扫码预览在项目文件夹下运行以下命令npm run server服务器启动后会显示如下的二维码，打开手机上的“快应用调试器”，点击“扫码安装”，扫这个二维码即可安装快应用进行预览。 推荐使用方法一，方法二可能扫描识别不了二维码。 如果看到如下界面，表示你已经成功开启了【快运用】的大门了，可以愉快的开始学习快运用了。 OK,至此快运用的介绍就到这里了。如果感兴趣的可以到官网了解更多官方文档 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>快运用</category>
      </categories>
      <tags>
        <tag>快运用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教学视频 | git的基本命令使用教学视频]]></title>
    <url>%2F2018%2F04%2F01%2FgitLearnMovie%2F</url>
    <content type="text"><![CDATA[前言git是当今非常流行的版本控制管理器，在项目开发中使用得非常多。但是很多人去网上看着文章学习的时候总会出现一些大大小小的错误，导致操作失败。这是一个全程录制的教学视频，每一步都很详细，希望能够帮助到你并能够顺利的使用git。 视频中的git命令清单可以参看我的博客【Git 常用的基本命令】 演示视频（可全屏观看） git的基本命令123456789101112131415161718192021222324252627282930配置git config –global user.name “Your Name”git config –global user.email “email@example.com“本地仓库—&gt;远程仓库的基本步骤git init 新建一个仓库git status 查看仓库当前的状态git add 可反复多次使用，添加多个文件；git add ./–all 添加当前文件夹的所有文件git commit -m “修改内容” 提交到本地仓库git remote 查看当前配置有哪些远程仓库git remote add origin https://github.com/WangHuagang/git-demo.git 将文件添加到指定的GitHub上的仓库git push -u origin master(分支) 将文件推送到远程仓库上git pull origin master(将远程仓库的东西“拉”回来)其余常用的命令git status -s 查看变更日志git log 可以查看提交日志git reset –hard (6位版本号) 回归到指定版本git diff 可以用于对比当前状态和版本库中状态的变化git branch 查看分支git branch （分支名） 创建一个新的分支git checkout （分支名） 切换分支git clone https://github.com/WangHuagang/git-demo.git .(.表示当前目录) 将远程仓库整个项目克隆到当前目录git merge 合并某分支到当前分支git branch -d 删除分支将本地文件放在github上显示1.创建gh-pages分支，利用gh-pages分支上传到远程仓库2.配置文件CNAME：绑定域名 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[夜神 Android studio连接配置第三方模拟器·夜神]]></title>
    <url>%2F2018%2F03%2F30%2FAndroid-studio%E8%BF%9E%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E6%8B%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Android Studio怎样连接配置第三方模拟器前言想必大家都体验了一把Android studio的环境搭建，总会出现莫名其妙的问题，刚刚搭建好，写好“Hello World”准备运行，折腾了半天，结果AS自带的模拟器运行不上，缺少一个加速软件。到这里，心已经凉了一大截了，好吧，换第三方模拟器，genymotion肯定是首选。到官网进行注册，然后下载下来，傻瓜式的安装好genymotion和virtualbox，眼看就要成功了，报错，纳尼！！！居然报错了！没错，他就是报错了。又捣鼓半天，放弃了，再找找其他的第三方模拟器吧，好吧，现在直接步入正题。 夜神模拟器夜神安卓模拟器，电脑玩手游的新一代神器。是当前唯一一款采用世界领先的内核技术（基于Android4.4.2 版本内核针在电脑上运行深度开发），具有同类模拟器中最快的运行速度 和最稳定的性能。玩家可以通过本软件在电脑上玩手机游戏， 感受更大的屏幕、更快的速度、更完美的操控体验。直接步入正题。 下载夜神模拟器 官网下载 傻瓜式安装好夜神。 运行夜神模拟器。 打开命令行窗口。 cd到夜神的安装目录（如cd D:\Program Files\NOX\Nox\bin）。 执行以下命令：nox_adb.exe connect 127.0.0.1:62001，连接上模拟器。 在Android studio中运行app，弹出的ADB中选择连接好的夜神就可以了。 若Android Studio连接不上夜神，重启连接模拟器即可链接上。 OK，现在你就可以愉快的敲你的代码了！有什么问题可以给我留言哦。 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数排序·JavaScript实现]]></title>
    <url>%2F2018%2F03%2F29%2F%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序算法计数排序计数排序就是遍历数组记录数组下的元素出现过多次，然后把这个元素找个位置先安置下来，简单点说就是以原数组每个元素的值作为新数组的下标，而对应小标的新数组元素的值作为出现的次数，相当于是通过下标进行排序。 算法原理计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。 时间复杂度它的复杂度为Ο(n+k)（其中k是整数的范围）。 代码实例1234567891011121314151617181920function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var k = 0; k &lt;len; k++) &#123; var length = C[k]; for(var m = 0 ;m &lt;length ; m++)&#123; B.push(k); &#125; &#125; return B; &#125; var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2]; console.log(countingSort(arr)); 计数排序动画演示 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>js算法</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序·JavaScript实现]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序算法插入排序插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据。 算法原理可以这么理解，在一个数组中我们不知道哪个是最小值，那么就假定第一个就是最小值，然后取第二个值与第一个值比较产排序后的序列，然后再取第三个值与排序后的序列进行比较插入到对应的位置，依次类推。 时间复杂度若数据的初始状态是正序的，那么只需要扫描一趟就完成了。此时是最好的时间复杂度：O(n)。若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。平均时间：O(n^2)。 代码实例1234567891011121314function insertionSort(array) &#123; for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while ( array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; return array; &#125; var arr=[2,5,3,6,1,7,9,4]; console.log(insertionSort(arr)); 插入排序动画演示]]></content>
      <categories>
        <category>js算法</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序·JavaScript实现]]></title>
    <url>%2F2018%2F03%2F27%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序算法快速排序通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法原理可以这么理解，在一个数组中我们不知道哪个是最小值，那么就假定第一个就是最小值，然后取第二个值与第一个值比较产排序后的序列，然后再取第三个值与排序后的序列进行比较插入到对应的位置，依次类推。 时间复杂度若数据的初始状态是正序的，那么只需要扫描一趟就完成了。此时是最好的时间复杂度：O(n)。若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。平均时间：O(n^2)。 代码实例123456789101112131415161718var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; console.log(pivot);//查看每一次的中间点 var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right)); &#125;; var arr=[2,5,3,6,1,7,9,4]; console.log(quickSort(arr)); 快速排序动画演示 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>js算法</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序·JavaScript实现]]></title>
    <url>%2F2018%2F03%2F26%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序算法选择排序选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 算法原理对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。 时间复杂度若数据的初始状态是正序的，那此时是最好的时间复杂度：O(n^2)。若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。平均时间：O(n^2)。 代码实例12345678910111213141516171819function xz(arr)&#123; var len=arr.length; var minIndex,temp; for(var i=0;i&lt;len-1;i++)&#123; minIndex=i; for(var j=i+1;j&lt;len;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123;//判断更小的数 minIndex=j; &#125; &#125; temp=arr[i]; arr[i]=arr[minIndex]; arr[minIndex]=temp; &#125; return arr;&#125;var arr=[2,5,3,6,1,7,9,4];console.log(xz(arr)) 选择排序动画演示 当数据量比较小时（1000左右），使用选择排序比冒泡排序更快。 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>js算法</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序·JavaScript实现]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序算法冒泡排序它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 算法原理比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度若数据的初始状态是正序的，那么只需要扫描一趟就完成了。此时是最好的时间复杂度：O(n)。若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。平均时间：O(n^2)。 代码实例1.最基础，也是最容易理解的一种做法。123456789101112131415function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;var arr=[2,5,3,6,1,7,9,4];console.log(bubbleSort(arr)); 2.更简单一点的，但不是那么容易理解的一种算法。12345678910111213141516function bubbleSort2(arr) &#123; var i = arr.length-1; //初始时,最后位置保持不变 while ( i&gt; 0) &#123; var pos= 0; //每趟开始时,无记录交换 for (var j= 0; j&lt; i; j++)&#123; if (arr[j]&gt; arr[j+1]) &#123; pos= j; //记录交换的位置 var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; &#125; i= pos; //为下一趟排序作准备 &#125; return arr;&#125;var arr=[2,5,3,6,1,7,9,4];console.log(bubbleSort2(arr)); 冒泡排序动画演示 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>js算法</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日9个】CSS3重要知识点总结（五）（完结）]]></title>
    <url>%2F2018%2F03%2F24%2Fcss305%2F</url>
    <content type="text"><![CDATA[1.position:fixed;在android下无效怎么处理？&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt; 2.如果需要手动写动画，你认为最小时间间隔是多久，为什么？多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。 3.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。解决方法：1.可以将&lt;li&gt;代码全部写在一排2.浮动li中float：left3.在ul中用font-size：0（谷歌不支持）；可以使用letter-space：-3px 4.display:inline-block 什么时候会显示间隙？1.有空格时候会有间隙 解决：移除空格2.margin正值的时候 解决：margin使用负值3.使用font-size时候 解决：font-size:0、letter-spacing、word-spacing 5.有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度外层div使用position：relative；高度要求自适应的div使用position: absolute; top: 100px; bottom: 0; left: 0 6.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？1 png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。2.jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。3.gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果.4.webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。 7.style标签写在body后与body前有什么区别？页面加载自上而下 当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题） 8.CSS属性overflow属性定义溢出元素内容区的内容会如何处理?参数是scroll时候，必会出现滚动条。参数是auto时候，子元素内容大于父元素时出现滚动条。参数是visible时候，溢出的内容出现在父元素之外。参数是hidden时候，溢出隐藏。 9.阐述一下CSS Sprites将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background- repeat，background-position 的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节. 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日9个】CSS3重要知识点总结（四）]]></title>
    <url>%2F2018%2F03%2F22%2Fcss304%2F</url>
    <content type="text"><![CDATA[1.margin和padding分别适合什么场景使用？何时使用margin：1.需要在border外侧添加空白2.空白处不需要背景色3.上下相连的两个盒子之间的空白，需要相互抵消时。何时使用padding：1.需要在border内侧添加空白2.空白处需要背景颜色3.上下相连的两个盒子的空白，希望为两者之和。 兼容性的问题：在IE5 IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display：inline解决。 2.元素竖向的百分比设定是相对于容器的高度吗？当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。 3.全屏滚动的原理是什么？用到了CSS的哪些属性？1.原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现2.overflow：hidden；transition：all 1000ms ease； 4.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。&lt;meta name=&quot;’viewport’&quot; content=&quot;”width=device-width,&quot; initial-scale=&quot;1.&quot; maximum-scale=&quot;1,user-scalable=no”&quot;/&gt; 5.视差滚动效果？视差滚动通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。1.CSS3实现优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器2.jQuery实现通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。优点：能兼容到各个版本的，效果可控性好缺点：开发起来对制作者要求高3.插件实现方式例如：parallax-scrolling，兼容性十分好,在线demo 6.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用1.单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。2.::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after 7.你对line-height是如何理解的？行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。多行文本垂直居中：需要设置display属性为inline-block。 8.怎么让Chrome支持小于12px 的文字？p{font-size:10px;-webkit-transform:scale(0.8);} //0.8是缩放比例 9.让页面里的字体变清晰，变细用CSS怎么做？-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用-webkit-font-smoothing：antialiased是最佳的，灰度平滑。 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日9个】CSS3重要知识点总结（三）]]></title>
    <url>%2F2018%2F03%2F21%2Fcss303%2F</url>
    <content type="text"><![CDATA[1.对BFC规范(块级格式化上下文：block formatting context)的理解BFC规定了内部的Block Box如何布局。定位方案：1.内部的Box会在垂直方向上一个接一个放置。2.Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。3.每个元素的margin box 的左边，与包含块border box的左边相接触。4.BFC的区域不会与float box重叠。5.BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。6.计算BFC的高度时，浮动元素也会参与计算。满足下列条件之一就可触发BFC1.根元素，即html2.float的值不为none（默认）3.overflow的值不为visible（默认）4.display的值为inline-block、table-cell、table-caption5.position的值为absolute或fixed 2.为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。浮动带来的问题：1.父元素的高度无法被撑开，影响与父元素同级的元素2.与浮动元素同级的非浮动元素（内联元素）会跟随其后3.若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。清除浮动的方式：1.父级div定义height2.最后一个浮动元素后加空div标签 并添加样式clear:both。3.包含浮动元素的父标签添加样式overflow为hidden或auto。4.父级div定义zoom 3.上下margin重合的问题在重合元素外包裹一层容器，并触发该容器生成一个BFC。例子：1234567891011121314151617181920&lt;div class="aside"&gt;&lt;/div&gt;&lt;div class="text"&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--下面是css代码--&gt;.aside &#123; margin-bottom: 100px; width: 100px; height: 150px; background: #f66; &#125; .main &#123; margin-top: 100px; height: 200px; background: #fcc; &#125; .text&#123; /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/ overflow: hidden; //此时已经触发了BFC属性。 &#125; 4.设置元素浮动后，该元素的display值是多少？自动变成display:block. 5.移动端的布局用过媒体查询吗？通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。1.里边&lt;link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only screen and (max-device-width:480px)”&gt;2.CSS : @media only screen and (max-device-width:480px) {/css样式/} 6.CSS 预处理器Less和sass，具体的可以自行了解一下。 7.CSS优化、提高性能的方法有哪些？1.避免过度约束2.避免后代选择符3.避免链式选择符4.使用紧凑的语法5.避免不必要的命名空间6.避免不必要的重复7.最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么8.避免！important，可以选择其他选择器9.尽可能的精简规则，你可以合并不同类里的重复规则 8.浏览器是怎样解析CSS选择器的？CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。 9.在网页中的应该使用奇数还是偶数的字体？为什么呢？使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日9个】CSS3重要知识点总结（二）]]></title>
    <url>%2F2018%2F03%2F20%2Fcss302%2F</url>
    <content type="text"><![CDATA[1.请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。试用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。 2.用纯CSS创建一个三角形的原理是什么？首先，需要把元素的宽度、高度设为0。然后设置边框样式。123456width: 0;height: 0;border-top: 40px solid transparent;border-left: 40px solid transparent;border-right: 40px solid transparent;border-bottom: 40px solid #ff0000; 3.一个满屏品字布局如何设计?第一种真正的品字： 三块高宽是确定的； 上面那块用margin: 0 auto;居中； 下面两块用float或者inline-block不换行； 用margin调整位置使他们居中。 第二种全屏的品字布局:上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行。 4.常见的兼容性问题？ 不同浏览器的标签默认的margin和padding不一样。*{margin:0;padding:0;} IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。 渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“9”这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 123456&#123;background-color:#f1ee18;/*所有识别*/.background-color:#00deff\9; /*IE6、7、8识别*/+background-color:#a200ff;/*IE6、7识别*/_background-color:#1e0bd1;/*IE6识别*/&#125; 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。 IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {} 5.为什么要初始化CSS样式因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 6.absolute的containing block计算方式跟正常流有什么不同？无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断： 若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形； 否则,则由这个祖先元素的 padding box 构成。 如果都找不到，则为 initial containing block。补充： static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分） absolute: 向上找最近的定位为absolute/relative的元素 fixed: 它的containing block一律为根元素(html/body) 7.CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？当一个元素的visibility属性被设置成collapse值后，对于一般的元素，它的表现跟hidden是一样的。 chrome中，使用collapse值和使用hidden没有区别。 firefox，opera和IE，使用collapse值和使用display：none没有什么区别。 8.display:none与visibility：hidden的区别？display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘） 9.position跟display、overflow、float这些特性相互叠加后会怎么样？display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日9个】CSS3重要知识点总结（一）]]></title>
    <url>%2F2018%2F03%2F19%2Fcss301%2F</url>
    <content type="text"><![CDATA[1.什么是标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin 2.box-sizing属性？用来控制元素的盒子模型的解析模式，默认为content-boxcontext-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽 3.CSS选择器有哪些？哪些属性可以继承？CSS选择符：id选择器(#myid)类选择器(.myclassname)标签选择器(div, h1, p)相邻选择器(h1 + p)子选择器（ul &gt; li）后代选择器（li a）通配符选择器（*）属性选择器（a[rel=”external”]）伪类选择器（a:hover, li:nth-child）可继承的属性：font-size, font-family, color不可继承的样式：border, padding, margin, width, height优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ]!important 比内联优先级高 4.CSS优先级算法如何计算？元素选择符： 1class选择符： 10id选择符：100元素标签：10001.!important声明的样式优先级最高，如果冲突再进行计算。2.如果优先级相同，则选择最后出现的样式。3.继承得到的样式的优先级最低。 5.CSS3新增伪类有那些?p:first-of-type 选择属于其父元素的首个元素p:last-of-type 选择属于其父元素的最后元素p:only-of-type 选择属于其父元素唯一的元素p:only-child 选择属于其父元素的唯一子元素p:nth-child(2) 选择属于其父元素的第二个子元素:enabled :disabled 表单控件的禁用状态。:checked 单选框或复选框被选中。 6.如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？1234border: 1px solid red;margin: 0 auto;height: 50px;width: 80px; 浮动元素的上下左右居中：12345678border: 1px solid red;float: left;position: absolute;width: 200px;height: 100px;left: 50%;top: 50%;margin: -50px 0 0 -100px; 绝对定位的左右居中：1234567border: 1px solid black;position: absolute;width: 200px;height: 100px;margin: 0 auto;left: 0;right: 0; 除此之外还可以用flexbox。 7.display有哪些值？说明他们的作用?inline（默认）–内联none–隐藏block–块显示table–表格显示list-item–项目列表inline-block 8.position的值？static（默认）：按照正常文档流进行排列；relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；absolute(绝对定位)：参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位；fixed(固定定位)：所固定的参照对像是可视窗口。 9.CSS3有哪些新特性？1.RGBA和透明度2.background-image background-origin(content-box/padding-box/border-box) background-size background-repeat3.word-wrap（对长的不可分割单词换行）word-wrap：break-word4.文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）5.font-face属性：定义自己的字体6.圆角（边框半径）：border-radius 属性用于创建圆角7.边框图片：border-image: url(border.png) 30 30 round8.盒阴影：box-shadow: 10px 10px 5px #8888889.媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[What is closure？怎样理解闭包]]></title>
    <url>%2F2018%2F03%2F19%2Fclosure%2F</url>
    <content type="text"><![CDATA[1.前言闭包这个东西在JavaScript中是一个很强大的东西，但是在初学的阶段总是被其概念绕晕，搞不清楚到底什么是闭包，感觉很高深。作者在刚学的时候也有一点懵圈，多看几次就会有自己的理解。任何东西都没有唯一的标准，只要适合自己，自己能够理解的就是正确的。由于作者水平有限，将自己的一些见解拿出来，希望大家能够提出宝贵的意见。 2.作用域在正式讲闭包之前，我们来简单的说一说作用域这个东西。这个很有助于大家理解后面的闭包。什么是域？简单的说就是一个被圈起来的地方，也就是变量能够访问的一个范围。众所周知，变量的作用域分为全局变量和局部变量。定义在函数外部的称为全局变量，在函数内部的称为局部变量。这里顺带提一下，变量提升这个玩意儿，也就是和“先声明后使用差不多的道理”，后面我将会举一个例子来说明。举个例子，全局变量和局部变量:123456789101112var a='wang';function fun()&#123; var b='huagang'; console.log('这是在函数内部的输出'); console.log(a); console.log(b);&#125;fun();//调用函数console.log("这是在函数外部的输出");console.log(a);console.log(b); 运行结果:最后一个输出b的时候抛出了一个未定义异常，由此可见，全局变量（a）在函数内部和外部都是能访问的，但是局部变量不是这样的，在函数作用域外是不能访问到函数内部的变量（b）的。这里顺带讲一下【变量提升】吧，简单的举一个例子。1234var a;console.log(a);a='wang';console.log(a) 根据输出情况可以看出，第一次输出a并没有报异常，而是undefined。第二次便能输出a的值。这就是变量提升的特点，在变量还没赋值前就拿来使用了。 3.嵌套函数的作用域嵌套函数，顾名思义就是在函数的内部再写一个或多个函数。下面举一个例子来讲解一下嵌套函数的作用域。12345678910111213141516function funA(c)&#123; var a='wang'; function funB()&#123; var b='gang'; console.log("在函数B中的输出：") console.log(a); console.log(c); console.log(b); &#125; funB(); console.log("在函数A中的输出：") console.log(a); console.log(c); console.log(b);&#125;funA('hua');//调用函数A并传参 函数B就是嵌套在函数A中的嵌套函数，它可以继承函数A的变量和参数，但是B中的变量A是不能访问的，就好像B给自己的门上了锁，“只进不出”，我可以拿你的东西，但是你不可以拿我的东西。B这样就形成了一个自己独有的封闭空间，这就是一个闭包。从不同的角度来看：从语法结构上看，函数A包含函数B；从作用域来看，函数B包含函数A，也就是说B能访问的空间比A大。因此可以想象得出，假如B函数中还有一个嵌套函数X，那么这个X函数也是一个闭包，作用域包含B和A。这样下去就形成了一个作用域链。 4.闭包相信通过上面的讲解，大家已经懂得了什么是闭包，现在再讲讲一些关于闭包的特点或者特性吧。 保存变量什么是保存变量？加入B这个闭包需要两个变量才能运行，但是刚开始只传了一个参数进去，所以这时候闭包就会把这个变量的值进行保存，等待第二个变量传入，而不是丢弃这个变量的值。下面举一个例子进行说明吧。123456789function funA(a)&#123; function funB(b)&#123; return a + b; &#125; return funB;//调用函数B的引用&#125;var x = funA(2);var sum = x(3);console.log(sum);//输出结果 5 当函数A传进参数a=2时，这时闭包B就将a进行保存，等到再传b=3时再进行计算。这就是闭包的保存变量。 5.为什么要使用闭包使用闭包的最大的好处——避免变量的污染。也就是说你在闭包中声明的变量不会影响在其他地方也使用这个变量名称，因为闭包将这个变量锁在自己的门里面保护起来了，外部是无法修改的。1234567891011function funA()&#123; function funB(b)&#123; var a = 'wang';//内部变量 c return a+b ; &#125; return funB;&#125;var a = 'hua';//外部变量x，是不能改变闭包B中的变量a的var sum = funA()(a);console.log(a);console.log(sum); 可以看出，外部变量是不能修改闭包中的变量a的值的，从而保护了a的值，使其不会受到污染。 闭包的分享就讲到这里啦，我相信大家能够对闭包能够有一定的了解。当然，由于作者水平有限，这只是个人的见解，有误的地方还希望多多包涵，或者留言告知我。 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js如何实现倒计时的原理分析及实现]]></title>
    <url>%2F2018%2F03%2F18%2FcountDown%2F</url>
    <content type="text"><![CDATA[js倒计时原理倒计时=预计时间点-当前时间点最后将倒计时转换成我们所需要的格式即可（eg：时分*秒）再使用setInterval(function, 1000);每一秒执行一次，动态刷新一次就好。 js代码实现timer 1234567891011121314151617181920212223countDown();timer = setInterval(countDown, 1000);// 倒计时计算函数function countDown()&#123; var nowTime = new Date(); // 获取当前日期 var endTime = new Date(2018,4,20,20,35,0); //预计时间，注意month需要减1 var t = Math.floor((endTime - nowTime)/1000); // 计算差值（单位：秒） var Day = Math.floor(Math.floor(t/86400)); // 天（86400 = 24*3600） var Hour = Math.floor(t%86400/3600); // 时 var Min = Math.floor((t%3600)/60); // 分 var Sec = t%60; // 秒 if ( t==0 )&#123; clearInterval(timer); document.getElementById(&quot;showDiv&quot;).innerHTML = &quot;倒计时结束！&quot;; &#125; else &#123; document.getElementById(&quot;showDiv&quot;) = &quot;倒计时还有：&quot; + add(Day) + &quot;天&quot; + add(Hour) + &quot;:&quot; + add(Min) + &quot;:&quot; + add(Sec); &#125;&#125;function add(iNum)&#123; return iNum&lt;10 ? &quot;0&quot;+iNum : iNum; //若时间是个位数，则添加一个0在前面&#125; 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实战数据结构——列表/元组]]></title>
    <url>%2F2018%2F03%2F18%2FsingCount%2F</url>
    <content type="text"><![CDATA[Python实战题目比赛评分：校园歌手大奖赛中，每个歌手的得分由10名评委和观众决定，最终得分的规则是去掉10名评委所打分数的一个最高分和一个最低分，再加上所有观众评委分数后的平均值。请编写程序输入某个选手的10个评委分数和观众评分，计算其最后得分。 实战分析1.先接受用户输入的所有数据，存在列表中，此时的数据为字符串，应当转换成float，因为求平均分可能会出现小数。 2.利用Python的内置函数sort()进行排序，这里不用管是升序还是降序。 3.利用pop函数去掉第一个和最后一个数，即达到了去掉最高分和最低分的要求。 4.利用for in 遍历出剩下的所有数，并进行求和sum。 5.将sum与观众的分相加除以总人数便可算出最终得分。 Python代码123456789101112sum=0;inputScore=input("请输入10个分数，以,隔开:");aScore=input("请输入观众评分：")splitScore=inputScore.split(',');intScore = list(map(float, splitScore))# 把字符串转化成floatintScore.sort()intScore.pop();#去除末尾的数intScore.pop(0);#去除最开始的数for x in intScore: sum+=x;avg=(sum+float(aScore))/(len(intScore)+1);print("该选手最终得分：%.2f"%avg) 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base64编码的原理及分析]]></title>
    <url>%2F2018%2F03%2F18%2Fbase64%2F</url>
    <content type="text"><![CDATA[1.为什么要使用base64编码因为有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，像ASCII码的控制字符就不能通过邮件传送。这样就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。最好的方法就是在不改变传统协议的情况下，开辟一种新的方案来支持二进制文件的传送。把不可见字符用可见字符来表示。而Base64就是一种基于64个可见字符来表示二进制数据的表示方法。 提示：不可见字符其实并不是不显示，只是这些字符在屏幕上显示不出来，比如：换行符、回车、退格等字符。 2.base64编码的原理Base64可以将ASCII字符串或者是二进制编码成只包含A—Z，a—z，0—9，+，/ 这64个字符（ 26个大写字母，26个小写字母，10个数字，1个+，一个 / 刚好64个字符）。 Base64的编码规则是将3个8位字节(3×8=24位)编码成4个6位的字节(4×6=24位)，之后在每个6位字节前面，补充两个0，形成4个8位字节的形式，那么取值范围就变成了0~63。又因为2的6次方等于64，所以每6个位组成一个单元。 下图为base64的字符转换表： 说太多了感觉复杂，直接上例子： 该图片转载自 https://www.jianshu.com/p/dd8bffc91c3d 所以，abc的base64的编码为YWJj；ab的base64编码为YWI=；a的base64编码为YQ==。 若末尾的为0，则对应的是A，但通常都用=来表示。因为 = 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 = 时即可知道一个Base64编码字符串结束。解码是对编码的逆向操作，但注意一点：对于最后的两个 = 字符，转换成两个A 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息。 在实际开发过程中，base64一般用于字符和图片的编码，最后，推荐一个在线base64的编码与解码网址：base64编码 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用的基本命令]]></title>
    <url>%2F2018%2F03%2F17%2FgitLearn%2F</url>
    <content type="text"><![CDATA[配置git config –global user.name “Your Name”git config –global user.email “email@example.com“ 本地仓库—&gt;远程仓库的基本步骤git init 新建一个仓库git status 查看仓库当前的状态git add 可反复多次使用，添加多个文件；git add ./–all 添加当前文件夹的所有文件git commit -m “修改内容” 提交到本地仓库git remote 查看当前配置有哪些远程仓库git remote add origin https://github.com/WangHuagang/git-demo.git 将文件添加到指定的GitHub上的仓库git push -u origin master(分支) 将文件推送到远程仓库上git pull origin master(将远程仓库的东西“拉”回来) 其余常用的命令git status -s 查看变更日志git log 可以查看提交日志git reset –hard (6位版本号) 回归到指定版本git diff 可以用于对比当前状态和版本库中状态的变化git branch 查看分支git branch （分支名） 创建一个新的分支git checkout （分支名） 切换分支git clone https://github.com/WangHuagang/git-demo.git .(.表示当前目录) 将远程仓库整个项目克隆到当前目录git merge 合并某分支到当前分支git branch -d 删除分支 将本地文件放在github上显示1.创建gh-pages分支，利用gh-pages分支上传到远程仓库2.配置文件CNAME：绑定域名 git搭建自己的博客1.npm install hexo-cli -g 安装hexo2.hexo init blog 新建一个博客仓库3.cd blog 到博客文件夹下4.npm install 安装需要的包5.hexo serve 开启博客 hexo搭建博客更多的配置将会在后面继续更新 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9步教你搭建个人博客(Hexo+Github)]]></title>
    <url>%2F2018%2F03%2F17%2FhexoBlog%2F</url>
    <content type="text"><![CDATA[1.下载并安装node.js和npm（新版本的node已经自带npm，不用单独下载） 2.安装git的环境，傻瓜式的安装方法，默认安装即可 3.注册github账号，并创建一个新的仓库，仓库的格式一定要按照这种格式来：name.github.io，其他的默认就好 4.安装hexo，在电脑某个合适的地方新建一个文件夹（eg：blog），然后命令行进入到该文件夹，按照以下步骤进行安装-安装hexonpm install hexo -g-检查是否安装成功hexo -v-初始化该文件夹hexo init-安装所需要的组件hexo install-体验一下hexohexo g-开启服务器，正式访问网址体验hexo，输入localhost:4000访问hexo s若出现下图，启动服务器成功若不能成功，可能是端口冲突，请输入以下命令进行切换端口hexo server -p当看见出现以下页面，表示博客基本框架搭建成功 5.将hexo与GitHub联系起来，配置name和email（ps：如果已经配置过的可以忽略），在blog文件夹中右键打开Git Bash进行配置git config --global user.name &#39;your github name&#39;git config --global user.email &#39;your github email&#39; 5.1输入ssh-keygen -t rsa -C “cdu.whg@foxmail.com” ,连续按三个回车键，生成秘钥，得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。5.2 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent。5.3 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent。5.4 登陆GitHub，点击头像下拉菜单中的setting，添加ssh 5.5 新建一个new SSH Key ，输入名称和秘钥（id_rsa.pub文件中的秘钥）即可 6.配置，找到根文件夹下的_config.yml文件，按照下图进行修改配置 7.开启写博客之旅，输入一下命令，建立第一篇bloghexo new post &#39;blogName&#39; 在source/_posts目录下可看见增加了一个hello.md文件，编辑该文件内容，便可发布博客了 8.在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save9.安装完后便可以部署了，使用hexo d -g进行部署 部署成功后访问你的地址：http://用户名.github.io。那么就能看到生成发布的文章了。 OK，使用hexo+GitHub搭建基本的个人博客就完成了，后续会推出【提升版】，对个人博客进行更精致的设置以及绑定自己的域名。console.log(&quot;敬请关注!&quot;) 转载文章时请注明本文的出处 || 咕噜先森的博客 作者-&gt;@王华港 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
</search>
